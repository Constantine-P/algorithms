# Основы анализа

В этом разделе мы познакомимся с основными понятиями, использующимся для анализа эффективности алгоритмов. Начнем с рассмотрения двух видов эффективности: временной и пространственной. ***Временная эффективность (time efficiency)*** является индикатором скорости работы алгоритма. ***Пространственная эффективность (space efficiency)*** показывает, сколько дополнительной оперативной памяти нужно для работы алгоритма. На заре развития электронных вычислительных машин (ЭВМ) особое значение имели два ресурса; быстродействие центрального процессора и объем оперативной памяти. Однако более чем полувековой процесс непрерывного технического прогресса привел к тому, что быстродействие и объем оперативной памяти вычислительных устройств увеличились во много раз. Теперь требования к дополнительному объему оперативной памяти, необходимой для работы алгоритма, стали не так важны, как раньше. Однако здесь следует сделать оговорку, что, конечно же, существует определенная разница между быстрой основной памятью, относительно медленной вторичной памятью и кэш-памятью. Что касается временных характеристик алгоритма и быстродействия современных компьютеров, то здесь, к сожалению, нельзя сказать, что эти вопросы совсем сняты с повестки дня. Более того, исходя из опыта научных исследований, можно сказать, что для большинства задач удается добиться существенного выигрыша именно в скорости работы алгоритма, а не в сокращении требуемого объема памяти (зачастую первое происходит за счет второго). Поэтому по сложившейся во многих учебниках по алгоритмам хорошей традиции, мы в основном сосредоточим внимание на временной эффективности. Тем не менее описанную в этом разделе аналитическую основу вы можете с успехом применить и для анализа пространственной эффективности алгоритмов.

## Оценка размера входных данных

Начнем обсуждение с констатации очевидного факта, что время выполнения большинства алгоритмов напрямую зависит от размера вводимых данных (т.е. чем больше размер, тем дольше работает алгоритм). Например, довольно долго длится процесс сортировки больших массивов данных, перемножения больших матриц и т.п. Поэтому вполне логично описать эффективность алгоритма в виде функции от некоторого параметра `n`, связанного с размером входных данных<n>В некоторых алгоритмах для оценки размерности входных данных может использоваться сразу несколько параметров (например, количество вершин и ребер для тех алгоритмов, в которых граф представляется в виде связанных списков смежных вершин).</n>. В большинстве случаев выбрать такой параметр не представляет большого труда. Например, для задач, связанных с сортировкой, поиском, нахождением наименьшего элемента в списке и многих других, связанных с обработкой списков, таким параметром будет размер списка. Для задачи вычисления значения многочлена степени `n` <tex>p(x) = a_{n}x^{n} + ... + a_{0}</tex> таким параметром может быть степень многочлена или количество его коэффициентов, которое на единицу больше степени многочлена.
Ниже мы увидим, что подобное несущественное отличие не влияет на результаты анализа.

Конечно, бывают случаи, когда выбор параметра, показывающего размер входных данных, имеет особое значение. Один из примеров подобных случаев — перемножение двух матриц размером <tex>n \times n</tex>. Существует две подходящих единицы измерения размера данной задачи. Первая и наиболее часто используемая — это порядок матрицы `n`. Однако существует и другая, не менее подходящая единица измерения, — количество `N` перемножаемых элементов в матрицах. Последняя единица к тому же более универсальна, поскольку ее можно применять не только к квадратным матрицам. Поскольку существует простая формула, связывающая эти две единицы измерения, мы легко можем перейти от одной единицы к другой, однако искомая эффективность алгоритма будет в значительной степени отличаться в зависимости от того, какая из двух единиц измерения была использована при решении задачи (см. задачу 2 упражнения 2.1).

На выбор подходящей системы измерений размера задачи могут повлиять выполняемые рассматриваемым алгоритмом действия. Например, как оценить размер входных данных для алгоритма, выполняющего проверку орфографии? Если в алгоритме проверяется каждый вводимый символ, то оценить размер входных данных мы можем, подсчитав количество символов во входном потоке. Если же в алгоритме происходит обработка текста по словам, то нужно подсчитать количество слов во входном потоке.

Мы должны сделать специальное замечание по поводу оценки размера входных данных для алгоритмов, связанных с нахождением чисел, удовлетворяющих определенным условиям (например, проверяющих, является ли заданное целое число `n` простым). Для подобных алгоритмов кибернетики предпочитают оценивать размер входных данных по количеству битов b в двоичном представлении числа `n`:

<tex f="2.1">b = \lfloor log_{2} n \rfloor + 1</tex>

Подобная система измерений позволяет лучше оценить эффективность рассматриваемого алгоритма.

## Единицы измерения времени выполнения алгоритма

Мы должны рассмотреть еще один вопрос, касающийся единиц измерения времени выполнения алгоритма. Безусловно, для этой цели можно просто воспользоваться общепринятыми единицами измерения времени — секундой, миллисекундой и т.д. и с их помощью оценить время выполнения программы, реализующей рассматриваемый алгоритм. Однако у такого подхода существуют явные недостатки, поскольку результаты измерений будут зависеть от:

- быстродействия конкретного компьютера;
- тщательности реализации алгоритма в виде программы;
- типа компилятора, использованного для генерации машинного кода;
- точности хронометрирования реального времени выполнения программы.

Поскольку перед нами стоит задача измерения эффективности *алгоритма*, а не реализующей его программы, мы должны воспользоваться такой системой измерений, которая бы не зависела от приведенных выше посторонних факторов.

Один из возможных способов решения этой проблемы состоит в подсчете того, сколько раз выполняется каждая операция алгоритма. Однако подобный подход слишком сложен и, как мы увидим в дальнейшем, чаще всего не нужен. Поэтому мы должны составить список наиболее важных операций, выполняемых в алгоритме, называемых ***основными***, или ***базовыми операциями (basic operation)***, определить, какие из них вносят наибольший вклад в общее время выполнения алгоритма, и вычислить, сколько раз эти операции выполняются.

Как правило, составить список основных операций алгоритма совсем нетрудно. Обычно в него включают наиболее длительные по времени операции, выполняемые во внутреннем цикле алгоритма. Например, в большинстве алгоритмов сортировки используется метод сравнения двух элементов (ключей) списка, который сортируется. Для подобного типа алгоритмов основной является операция сравнения ключей. В качестве еще одного примера рассмотрим алгоритмы перемножения матриц и вычисления значения многочлена. В них используются две основные операции: умножение и сложение. На большинстве компьютеров команда умножения двух целых чисел выполняется намного дольше, чем сложение<n>Кроме компьютеров с так называемой RISC-архитектурой. В качестве примера сравните временные характеристики команд, приведенные в [[61], с. 185-186].</n>. Поэтому она является безусловным кандидатом на включение в список основных операций.

Таким образом, закладывая основу для анализа временной эффективности алгоритмов, мы предполагаем, что этот показатель будет оцениваться по количеству основных операций, которые должен выполнить алгоритм при обработке входных данных размера `n`, О том, как определить этот показатель для нерекурсивных и рекурсивных алгоритмов, вы узнаете из разделов 2.3 и 2.4, соответственно.

Рассмотрим один важный пример. Предположим, что <tex>c_{op}</tex> — время выполнения основной операции алгоритма на конкретном компьютере, а <tex>C(n)</tex> — количество раз, которые эта операция должна быть выполнена при работе алгоритма. Тогда время выполнения программной реализации этого алгоритма на данном компьютере <tex>T(n)</tex> можно приблизительно определить по следующей формуле:

<tex>T(n) \approx c_{op}C(n).</tex>

Разумеется, эту формулу нужно использовать очень аккуратно. В значении счетчика С (п) не учитывается количество выполняемых алгоритмом операций, не относящихся к основным. Кроме того, обычно значение этого счетчика также можно определить только приблизительно. Более того, значение константы Сор также можно определить лишь приблизительно и оценить ее точность весьма непросто. Тем не менее, эта формула дает приемлемую оценку времени выполнения алгоритма для не бесконечно больших и не бесконечно малых значений п. Она также позволяет ответить на вопросы наподобие: во сколько раз быстрее будет работать реализация данного алгоритма на компьютере, быстродействие которого больше нашего в 10 раз? Казалось бы, ответ очевиден — в 10 раз. Или пусть, например, С(п) = п ( п — 1)/2. Насколько дольше будет выполняться программа, если удвоить размер входных данных? Ответ будет такой: приблизительно в четыре раза медленнее. В самом деле, для достаточно больших п справедлива следующая формула:

<tex>C(n) = \frac{1}{2}n(n-1) = \frac{1}{2}n^{2} - \frac{1}{2}n \approx \frac{1}{2}n^{2}</tex>

Поэтому

<tex>\frac{T(2n)}{T(n)} \approx \frac{c_{op}C(2n)}{c_{op}C(n)} \approx \frac{0.5(2n)^2}{0.5n^2} = 4</tex>

Обратите внимание, что для ответа на второй вопрос не нужно знать реальное значение <tex>c_{op}</tex>, поскольку в приведенной выше дроби оно сокращается. Обратите также внимание, что постоянный множитель `1/2` в формуле для `C(n)` тоже сокращается. По этим причинам в процессе анализа эффективности при достаточно больших размерах входных данных не учитывают постоянные множители, а сосредотачиваются на оценке ***порядка роста (order of growth)*** количества основных операций с точностью до постоянного множителя.

## Порядок роста

Почему выше мы сделали замечание по поводу вычисления порядка роста количества основных операций алгоритма для достаточно больших размеров входных данных? Дело в том, что при малых размерах входных данных невозможно заметить разницу во времени выполнения между эффективным и неэффективным алгоритмом. Например, при вычислении НОД двух небольших чисел, совершенно непонятно во сколько раз алгоритм Евклида работает быстрее двух других алгоритмов, рассмотренных в разделе 1.1. Непонятным остается также вопрос, почему нас так волнует, какой из алгоритмов быстрее и во сколько раз. И только тогда, когда нужно вычислить НОД двух очень больших чисел, все эти вопросы, связанные с разной эффективностью алгоритмов, выходят на первый план и становятся понятными. Для больших значений п вычисляют порядок роста функции.
В табл. 2.1 эти значения приведены для некоторых функций, играющих особую роль в процессе анализа алгоритмов.

<table>
  <thead>
    <tr>
      <th colspan="8">
        Таблица 2.1. Приближенные значения важных для анализа алгоритмов функций
      </th>
    </tr>
    <tr>
      <th>
        <tex>n</tex>
      </th>
      <th>
        <tex>log_2 n</tex>
      </th>
      <th>
        <tex>n</tex>
      </th>
      <th>
        <tex>n \cdot log_2 n</tex>
      </th>
      <th>
        <tex>n^2</tex>
      </th>
      <th>
        <tex>n^3</tex>
      </th>
      <th>
        <tex>2^n</tex>
      </th>
      <th>
        <tex>n!</tex>
      </th>
    </tr>   
  </thead>
  <tbody>
    <tr>
      <th>
        <tex>10</tex>
      </th>
      <td>
        <tex>3.3</tex>
      </td>
      <td>
        <tex>10</tex>
      </td>
      <td>
        <tex>3.3 \cdot 10^1</tex>
      </td>
      <td>
        <tex>10^2</tex>
      </td>
      <td>
        <tex>10^3</tex>
      </td>
      <td>
        <tex>10^3</tex>
      </td>
      <td>
        <tex>3.6 \cdot 10^6</tex>
      </td>
    </tr>
    <tr>
      <th>
        <tex>10^2</tex>
      </th>
      <td>
        <tex>6.6</tex>
      </td>
      <td>
        <tex>10^2</tex>
      </td>
      <td>
        <tex>6.6 \cdot 10^2</tex>
      </td>
      <td>
        <tex>10^4</tex>
      </td>
      <td>
        <tex>10^6</tex>
      </td>
      <td>
        <tex>1.3 \cdot 10^{30}</tex>
      </td>
      <td>
        <tex>9.3 \cdot 10^{157}</tex>
      </td>
    </tr>
    <tr>
      <th>
        <tex>10^3</tex>
      </th>
      <td>
        <tex>10</tex>
      </td>
      <td>
        <tex>10^3</tex>
      </td>
      <td>
        <tex>1.0 \cdot 10^4</tex>
      </td>
      <td>
        <tex>10^6</tex>
      </td>
      <td>
        <tex>10^9</tex>
      </td>
      <td>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <th>
        <tex>10^4</tex>
      </th>
      <td>
        <tex>13</tex>
      </td>
      <td>
        <tex>10^4</tex>
      </td>
      <td>
        <tex>1.3 \cdot 10^5</tex>
      </td>
      <td>
        <tex>10^8</tex>
      </td>
      <td>
        <tex>10^{12}</tex>
      </td>
      <td>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <th>
        <tex>10^5</tex>
      </th>
      <td>
        <tex>17</tex>
      </td>
      <td>
        <tex>10^5</tex>
      </td>
      <td>
        <tex>1.7 \cdot 10^6</tex>
      </td>
      <td>
        <tex>10^{10}</tex>
      </td>
      <td>
        <tex>10^{15}</tex>
      </td>
      <td>
      </td>
      <td>
      </td>
    </tr>
    <tr>
      <th>
        <tex>10^6</tex>
      </th>
      <td>
        <tex>20</tex>
      </td>
      <td>
        <tex>10^6</tex>
      </td>
      <td>
        <tex>2.0 \cdot 10^7</tex>
      </td>
      <td>
        <tex>10^{12}</tex>
      </td>
      <td>
        <tex>10^{18}</tex>
      </td>
      <td>
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

Порядок чисел, приведенных в табл. 2.1, имеет чрезвычайное значение для анализа алгоритмов. Как видно из таблицы, самый малый порядок роста имеет логарифмическая функция. Причем его значение настолько мало, что программы, реализующие алгоритмы с логарифмическим количеством основных операций, будут выполняться практически мгновенно для всех диапазонов входных данных реального размера. Обратите также внимание, что, хотя некоторые значения при таких вычислениях, естественно, будут зависеть от основания логарифма, приведенная ниже формула позволяет легко переходить от одного основания логарифма к другому, сохраняя при этом логарифмическую зависимость вычислений (при этом используются новые постоянные множители):

<tex>log_a n = log_a b log_b n.</tex>

Вот почему в случае, когда нужно только определить порядок роста количества основных операций алгоритма с точностью до постоянного множителя, мы будем опускать основание логарифма и записывать просто: <tex>log n</tex>.

Существует и другая крайность: показательная функция <tex>2^n</tex> и функция вычисления факториала `n!`. Обе эти функции имеют настолько высокий порядок роста, что его значение становится астрономически большим уже при умеренных значениях `n`. (По этой причине мы не стали приводить в табл. 2.1 значения порядка роста этих функций при <tex>n > 10^2</tex>.) Например, чтобы выполнить <tex>2^100</tex> операций компьютеру, имеющему производительность в один триллион операций (<tex>10^12</tex>) в секунду, понадобиться без малого <tex>4 • 1О^10</tex> лет! Однако это ничто по сравнению со временем, которое затратит тот же компьютер на выполнение `100!` операций.

Его даже нельзя сравнить со временем жизни планеты Земля, которое, по приблизительным оценкам, составляет `4.5` миллиарда (<tex>4.5 • 10^9</tex>) лет. Несмотря на существенную разницу между порядком роста показательной функции <tex>2^n</tex> и функции `n!`, довольно часто говорят, что обе функции имеют экспоненциальный порядок роста. Однако, строго говоря, такое утверждение верно только для первой из этих функций. Подводя итог, можно сформулировать следующий вывод, который всегда важно помнить.

<def>С помощью алгоритмов, в которых количество выполняемых операций растет по экспоненциальному закону, можно решить лишь задачи очень малых размеров.</def>

Существует еще один способ оценки качественного различия в порядке роста функций, приведенном в табл. 2.1. Необходимо рассмотреть реакцию функции на, скажем, двукратное увеличение значения параметра `n`. Для функции <tex>log_2 n</tex> это приведет к увеличению значения всего на `1`, так как <tex>log_2 2n = log_2 2 + log_2 n = 1 + log_2 n</tex>. Линейная функция увеличит значение в два раза. Значение функции <tex>n log_2 n</tex> увеличится чуть больше, чем в два раза. Квадратичная <tex>n^2</tex> и кубическая <tex>n^3</tex> функции увеличатся в четыре и восемь раз, соответственно, поскольку <tex>(2n)^2 = 4n^2</tex> и <tex>(2n)^3 = 8n</tex>. Значение функции <tex>2^n</tex> увеличится в квадрате, поскольку <tex>n^{2n} = (2^n)^2</tex>. Что касается функции <tex>n!</tex>, то ее значение увеличится намного больше, чем значение любой из рассмотренных здесь функций.

## Эффективность алгоритма в разных случаях

В начале этого раздела мы определили, что имеет смысл оценивать эффективность алгоритма как функцию от некоторого параметра п, связанного с размером входных данных. Однако существует большое количество алгоритмов, время выполнения которых зависит не только от размера входных данных, но также и от особенностей конкретных входных данных. В качестве примера рассмотрим задачу последовательного поиска. Она решается с помощью довольно простого алгоритма, который выполняет поиск заданного элемента (ключа поиска `К`) в списке, состоящем из `n` элементов, путем последовательного сравнения ключа К с каждым из элементов списка. Работа алгоритма завершается, либо когда заданный ключ найден, либо когда весь список исчерпан. Ниже этот алгоритм описан на псевдокоде. В нем для простоты полагается, что список задан в виде массива чисел. (Кроме того, предполагается, что второе условие <tex>А[i] \neq K</tex> не будет проверяться в случае, если не выполняется первое условие, в котором проверяется, не выходит ли индекс массива за его верхнюю границу.)
