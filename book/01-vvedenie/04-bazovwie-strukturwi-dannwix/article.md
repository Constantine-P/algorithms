# Базовые структуры данных

Поскольку большинство рассматриваемых в этой книге алгоритмов выполняют обработку данных, то на процесс их проектирования и анализа существенно влияют конкретные способы организации данных. Понятие ***структуры данных*** (data structure) можно определить как особую систему организации взаимосвязанных элементов данных. Структура самих элементов данных зависит от задачи, в которой они используются. Они могут быть как очень простыми (например, представлять собой целые числа или строки символов), так и сложными структурами данных (например, для представления матриц часто используют одномерный массив, каждый элемент которого, в свою очередь, также является одномерным массивом). Тем не менее существует несколько чрезвычайно важных при проектировании алгоритмов для компьютеров структур данных. Поскольку вы наверняка знакомы с большинством из них (если не со всеми), ниже представлен лишь их краткий обзор.

## Линейные структуры данных

Среди простых структур данных можно выделить две самых важных — одномерный массив и связанный список. ***Одномерный массив*** (array) — это последовательность из `n` однотипных элементов, расположенных подряд в оперативной памяти компьютера, доступ к которым выполняется по значению так называемого ***индекса*** массива (см. рис. 1.6).

<img src="pic-1-06.svg" alt="Рис. 1.6. Одномерный массив из n элементов" width="70%" />

В большинстве случаев индекс массива, состоящего из `n` элементов, является целым числом и принимает значения от `0` до `n — 1` (как показано на рис. 1.6) или от `1` до `n`. В некоторых языках программирования допускается, чтобы индекс массива принимал любые целочисленные значения (в том числе и отрицательные).
Главное, чтобы он не выходил за пределы заранее установленного диапазона, определяющего *нижнюю* и *верхнюю* границы изменения индекса. Иногда в языках программирования для доступа к элементам массива могут использоваться нечисловые индексы. Подобные массивы называются *ассоциативными*. Например, можно создать ассоциативный массив из 12 элементов, соответствующий месяцам года, доступ к котором осуществляется по названиям месяцев.

Время обращения к любому элементу массива одинаково и не зависит от его положения в массиве. Эта особенность выгодно отличает массивы от связанных списков, о которых речь пойдет ниже. Однако не стоит забывать, что каждый элемент массива занимает одинаковое количество ячеек памяти компьютера.

На основе одномерных массивов создаются различные структуры данных. Среди них выделяются ***строки*** (string), т.е. последовательности символов заранее определенного алфавита, заканчивающиеся особым символом. Этот символ служит признаком конца строки. Строки, состоящие только из нулей или единиц, называются ***двоичными (бинарными)*** (binary strings) или ***битовыми*** (bit strings). Строки являются основным элементом, используемым при обработке текстовых данных, определении синтаксиса языка программирования, компилировании написанных на нем программ, а также при изучении абстрактных вычислительных моделей. Выполняемые над массивом операции в первую очередь зависят от его типа. Так, операции обычно выполняемые со строками, отличаются от операций, выполняемых над массивом чисел. В этот перечень входит:

- определение длины строки;
- сравнение двух строк, позволяющее определить, какая из них располагается раньше согласно так называемому лексикографическому порядку, т.е. как в словаре;
- объединение (конкатенация) двух строк, позволяющее сформировать из них одну строку, поместив вторую строку в конец первой.

***Связанный список*** — это последовательность (которая может быть пустой) нескольких элементов данных, называемых ***узлами*** (nodes). В каждом узле хранится информация двух видов: собственно данные узла и одна или несколько ссылок на другие узлы связанного списка, называемых ***указателями*** (pointers).
Если текущий узел связанного списка является последним, в него помещается т.н. нулевой указатель со специальным значением null; это говорит о том, что указатель ни на что не указывает. В ***однонаправленном связанном списке*** (singly linked list) каждый узел содержит только один указатель, в который помещается ссылка на следующий элемент списка, либо “ноль”, если текущий элемент является последним (рис. 1.7).

<img src="pic-1-07.svg" alt="Рис. 1.7. Однонаправленный связанный список, состоящий из n элементов" width="90%" />

Для обращения к заданному элементу связанного списка необходимо выбрать первый узел списка, а затем перемещаться по цепочке элементов до достижения нужного узла. Поэтому, в отличие от одномерных массивов, время, затрачиваемое на доступ к произвольному элементу однонаправленного списка зависит от его положения в списке. Это является существенным недостатком связанного списка. Однако у него есть и преимущество. Оно заключается в том, что для элементов связанного списка не требуется предварительное резервирование оперативной памяти компьютера. Кроме того, вставка и удаление элементов списка не представляют особого труда и выполняются достаточно быстро изменением значений нескольких указателей.

Гибкость структуры связанного списка позволяет использовать его различными способами во множестве приложений. Например, часто бывает очень удобно, чтобы в первом элементе связанного списка находился специальный узел, называемый заголовком (header). В него обычно помещают информацию о самом списке, такую как текущее количество элементов в списке и указатель на последний элемент списка.

Существует модификация структуры однонаправленного связанного списка, которая называется двунаправленным связанным списком (doubly linked list).

Отличие между ними в том, что каждый узел двунаправленного списка (кроме первого и последнего) содержит указатели на предыдущий и последующий узлы (рис. 1.8).

<img src="pic-1-08.svg" alt="Рис. 1.8. Двунаправленный связанный список, состоящий из n элементов" width="98%" />

Массив и связанный список чаще всего используются для представления еще одной абстрактной структуры данных, называемой линейным списком или просто списком. ***Список*** (list) представляет собой конечную последовательность элементов данных, т.е. набор элементов данных, организованных в заданном линейном порядке. К этой структуре данных могут применяться такие базовые операции, как поиск, добавление и удаление элемента.

Среди всего множества списков можно выделить два типа: стеки и очереди.
***Стеком*** (stack) называют такой список, в котором можно удалить только последний элемент, а новый элемент добавить только в его конец. Последний часто называют ***вершиной*** (top) стека, поскольку стеки обычно изображают на рисунках в виде вертикального прямоугольника (по аналогии со стопкой тарелок, которую он напоминает). Кратко сформулировать принцип работы стека можно так: “последним вошел, первым вышел” (“last-in-first-out”, или LIFO), поскольку первым из стека всегда удаляется элемент, добавленный в него последним. Этим стек напоминает стопку тарелок, поскольку мы можем взять из нее только верхнюю тарелку, а новую тарелку — положить на верх стопки. Стеки широко применяются на практике, в частности, без них не обойтись при реализации рекурсивных алгоритмов.

Под ***очередью*** (queue) понимается такой список, элементы которого удаляются с одной стороны структуры (она называется ***головой*** (front)), а добавляются с другой (она называется ***хвостом*** (rear)). Первая операция называется ***удалением*** элемента из очереди (dequeue), а вторая — ***постановкой*** в очередь (enqueue).
Таким образом, принцип работы очереди можно сформулировать так: “первым вошел, первым вышел” (“first-in-first-out”, или FIFO). Здесь прослеживается полная аналогия с очередью в магазине, которая образуется, если продавец медленно отпускает товар или наплыв покупателей слишком велик. Очереди также находят широкое практическое применение, в частности, в некоторых алгоритмах решения задач теории графов.

Во многих важных приложениях требуется выбрать среди динамически изменяемого множества элемент с наивысшим приоритетом. Часто для решения подобной задачи применяют структуру данных, которая называется ***очередью с приоритетами***, или ***приоритетной очередью*** (priority queue). Эта очередь представляет собой совокупность элементов данных, относящихся к вполне упорядоченному универсуму<n>Математический термин, означающий некоторое множество, фиксированное в рамках данной математической теории и содержащее в качестве элементов все объекты, рассматриваемые в этой теории. Употребляется как синоним термина универсальное множество. Математическая энциклопедия, т. 5, М.: Сов. энц., 1985. — Прим. ред.</n> (чаще всего целых или вещественных чисел). К основным операциям над очередью с приоритетами относятся: поиск наибольшего элемента, извлечение наибольшего элемента и добавление нового элемента. Само собой разумеется, что последние две операции должны быть реализованы так, чтобы в результате их выполнения получалась новая очередь с приоритетами (либо переупорядочивалась старая). Проще всего реализовать рассматриваемую структуру данных на основе массива или упорядоченного массива, однако ни одно из этих решений не является оптимальным в плане достижения максимально возможной эффективности. В более удачных реализациях используется оригинальная структура данных, называемая ***пирамидой*** (heap)<n>Изначально термин “heap” использовался в контексте пирамидальной сортировки (heapsort), но в последнее время его основной смысл изменился, и он стал обозначать память со сборкой мусора (в частности, в языках программирования Lisp и Java) и переводиться как “куча”. Однако в данной книге термину heap (который здесь переводится как “пирамида”) возвращен его первоначальный смысл. — Прим. ред.</n>. Эту структуру данных и основные алгоритмы сортировки на ее основе мы обсудим в разделе 6.4.

## Графы

Как уже упоминалось, граф нестрого можно определить как совокупность точек на плоскости, называемых вершинами, или узлами, часть из которых соединена отрезками, называемыми ребрами, или дугами. Строго ***граф*** <tex>G = \left\langle V, E \right\rangle</tex> определяется парой множеств: конечного множества элементов `V`, называемых ***вершинами***, и множества `E`, содержащего пары вершин, называемые ***ребрами***. Если пары вершин неупорядочены, т.е. пара вершин `(u, v)` означает то же самое, что и пара `(v, u)`, то такой граф называют неориентированным. Если же пары упорядочены, то говорят, что ребро `(u, v)` ориентировано из вершины `u` к вершине `v`, при этом сам граф `G` называют ***ориентированным*** (directed). Ориентированные графы называют также ***диграфами*** (digraph).

Для удобства вершины графа обозначают латинскими буквами, целыми числами или даже символьными строками, если этого требуют условия задачи (рис. 1.9).
Граф, показанный на рис. 1.9а, имеет 6 вершин и семь ребер:

<tex>V = \\{\ a, b, c, d, e, f\ \\},\ \ \ E = \\{\ (a, c), (a, d), (b, c), (b, f), (c, e), (d, e), (e, f)\ \\}.</tex>

Ориентированный граф, изображенный на рис. 1.9б, имеет шесть вершин и восемь ориентированных ребер (дуг):

<tex>V = \\{\ a, b, c, d, e, f\ \\},\ \ \ E = \\{\ (a, c), (b, c), (b, f), (c, e), (d, a), (d, e), (e, c), (e, f)\ \\}.</tex>

<img src="pic-1-09.svg" alt="Рис. 1.9. а) неориентированный граф; б) ориентированный граф" width="70%" />

В приведенном выше определении графа не исключены ***петли*** (loops), или ребра, начинающиеся и заканчивающиеся в одной вершине. В книге мы будем считать, что у графа не может быть петель, если явно не указано иное. Поскольку по определению не разрешается, чтобы между двумя вершинами неориентированного графа существовало несколько ребер, то для такого графа, имеющего `|V|` вершин и не содержащего петель, можно оценить количество возможных ребер `|Е|` с помощью следующего неравенства:

<tex>0 \leqslant |E| \leqslant \frac{|V| \ ( |V| - 1 )}{2}.</tex>

Если каждая из `|V|` вершин графа соединяется ребрами с остальными `|V| - 1` вершинами, то количество ребер в нем будет максимальным. Поскольку граф неориентированный, произведение `|V| (|V| - 1)` необходимо разделить на 2, поскольку между двумя вершинами `(u, v)` имеется 2 ребра: от `u` к `v` и от `v` к `u`.

Граф, в котором каждая пара вершин соединяется ребром, называется ***полным*** (complete). Стандартное обозначение полного графа, состоящего из `|V|` вершин, — <tex>K_{|V|}</tex>. Граф, в котором отсутствует относительно небольшое количество ребер, называется ***плотным*** (dense), и, напротив, граф, в котором присутствует относительно небольшое количество ребер<n>В этих определениях фразу “относительно небольшое” следует понимать как количество ребер, малое относительно количества ребер полного графа. — Прим. ред.</n>, называется ***разреженным*** (sparse). От того, с каким графом мы имеем дело (плотным или разреженным), зависит способ его представления и, следовательно, время выполнения разрабатываемого или используемого алгоритма.

## Представление графов

Графы, используемые в компьютерных алгоритмах, могут быть представлены двумя принципиально разными способами: в виде матрицы смежности и в виде связанных списков смежных вершин. ***Матрица смежности*** (adjacency matrix) графа, состоящего из `n` вершин, представляет собой булеву матрицу размером <tex>n \times n</tex>, в которой каждая строка и каждый столбец соответствуют одной из вершин графа. Элемент этой матрицы, находящийся на пересечении `i`-ой строки и `j`-го столбца, равен `1` в случае, если `i`-я и `j`-я вершины графа соединяются ребром, и `0` в противном случае<n>В общем случае значения элементов матрицы смежности равны не только 0 или 1 (т.е. матрица не является булевой). Каждый элемент матрицы, находящийся на пересечении i-й строки и j-ro столбца, соответствует количеству ребер, соединяющих i-ю и j-ю вершины графа. — Прим. ред.</n>. Например, на рис. 1.10а показана матрица смежности для графа, изображенного на рис. 1.9а. Обратите внимание, что матрица смежности для неориентированного графа всегда симметрична (понятно, почему?), т.е. <tex>A[i, j] = A[j, i]</tex> для всех <tex>0 \leqslant i, j \leqslant n - 1</tex>.

<img src="pic-1-10.svg" alt="Рис. 1.10. Матрица смежности а) и связанные списки смежных вершин б) для графа, изображенного на рис. 1.9а" width="60%" />

***Связанные списки смежных вершин*** (adjacency linked lists) графа представляют собой совокупность связанных списков (по одному для каждой вершины), в которых содержится информация обо всех смежных вершинах текущей вершины (т.е. в каждом связанном списке содержится список всех вершин, соединенных ребром с текущей вершиной). Как правило, в начале каждого подобного списка располагается заголовок, содержащий информацию, идентифицирующую вершину, для которой этот список составлен. Например, на рис. 1.10б с помощью связанных списков смежных вершин представлен граф, изображенный на рис. 1.9а. Если взглянуть на все с другой стороны, то в связанных списках присутствуют вершины графа, которым в матрице смежности соответствуют единичные элементы.

Связанные списки смежных вершин имеет смысл использовать для представления *разреженных* графов, поскольку при этом требуется меньше оперативной памяти по сравнению с матрицей смежности (которая, кстати, в этом случае будет состоять практически из одних нулей). Естественно, что дополнительную память, которую занимают указатели связанного списка, мы в расчет не принимаем. Однако ситуация в корне меняется в случае плотных графов. Вообще говоря, выбор способа представления графа зависит от типа задачи, алгоритма, используемого для ее решения и, возможно, от типа исходного графа (в зависимости от того, разреженный он или плотный).

## Взвешенные графы

Под ***взвешенным графом*** (weighted graph) подразумевается граф, ребрам которого поставлены в соответствие числа, как показано на рис. 1.11а. Эти числа называются ***весами*** (weights) или ***ценами***, или ***стоимостями*** (costs). Интерес к подобного типа графам был вызван большим количеством прикладных задач, таких как задача поиска кратчайшего маршрута между двумя пунктами или уже упоминавшаяся выше задача коммивояжера. Интересно, что определение кратчайшего пути может использоваться как при транспортировке грузов, так и в сетях передачи данных.

Оба рассмотренных выше способа представления графов легко приспособить и для случая взвешенных графов. Если взвешенный граф представляется с помощью матрицы смежности `A`, то ее элемент `A[i, j]` должен равняться весу ребра, соединяющего `i`-ю и `j`-ю вершины. Если же эти вершины не соединены ребром, то вместо веса элемент `A[i, j]`, должен содержать какой-нибудь специальный знак, например знак бесконечности <tex>\infty</tex>. Такая матрица называется ***матрицей весов*** (weight matrix) или ***матрицей стоимости*** (cost matrix). Подобный подход проиллюстрирован на рис. 1.11б. (В некоторых случаях удобнее, чтобы на главной диагонали матрицы смежности располагались нули, а не знаки бесконечности.) Что касается представления взвешенного графа с помощью связанных списков смежных вершин, то каждый узел списка нужно немного расширить, включив в него не только имя смежной вершины, но и весовой коэффициент соответствующего ребра, как показано на рис. 1.11в.

<img src="pic-1-11.svg" alt="Рис. 1.11. а) Взвешенный граф и его представление б) с помощью матрицы весов и в) связанных списков смежных вершин" width="85%" />

## Пути и циклы

Среди множества интересных свойств графа можно выделить два особенно важных для решения огромного количества прикладных задач: ***связность*** (connectivity) и ***ацикличность*** (acyclicity). Оба этих свойства основаны на понятии пути. ***Путь***, или ***маршрут***, (path) от вершины `u` к вершине `v` можно определить как последовательность смежных (т.е. соединенных ребром) вершин, которая начинается в вершине `u` и заканчивается в вершине `v`. Если все ребра графа различны, то такой путь называют ***простым*** (simple). Под ***длиной*** (length) пути понимается общее количество вершин в последовательности, определяющей путь, минус единица. Другими словами, длина пути равна количеству ребер, через которые он проходит. Например, на рис. 1.9а от вершины `a` до вершины `f` можно проложить простой путь длиной 3: `a, c, b, f`. В то же время между этими вершинами существует путь (не простой) длиной 5: `a, c, d, c, b, f`.

В случае ориентированных графов нас обычно будут интересовать ориентированные пути. Под ***ориентированным маршрутом*** (directed path) понимается последовательность вершин, в которой каждая следующая друг за другом пара вершин `(u, v)` соединена дугой, начинающейся в вершине `u` и заканчивающейся в вершине `v`. Например, на рис. 1.9б существует следующий ориентированный путь из вершины `a` к вершине `f`: `a, c, e, f`.

Граф называется ***связным*** (connected), если для любой пары его вершин `u` и `v` существует путь от `u` к `v`. Объяснить это свойство графа, что называется, “на пальцах” можно так: если создать модель этого графа, связав между собой веревками (которые будут выполнять роль ребер) несколько мячей (они будут выполнять роль вершин), то все предметы можно будет удержать в одной руке. Если граф не является связным, то модель будет состоять из нескольких отдельных участков, которые называются связными компонентами. Строго ***связный компонент*** (connected component) графа можно определить как максимальный связный подграф<n>Подграфом (subgraph) графа <tex>G = \left\langle V, E \right\rangle</tex> является граф <tex>G' = \left\langle V', E' \right\rangle</tex> такой, что <tex>V' \subseteq V</tex> и <tex>E' \subseteq E</tex>.</n> данного графа, который нельзя расширить за счет включения дополнительной вершины, смежной с одной из ее вершин. Например, графы, изображенные на рис. 1.9а и 1.11а, являются связными, тогда как граф, изображенный на рис. 1.12, не является связным, поскольку нельзя проложить путь, скажем, от вершины `a` к вершине `f`. Граф, изображенный на рис. 1.12, имеет два связанных компонента с вершинами `{ a, b, c, d, e }` и `{ f, g, h, i }` соответственно.

<img src="pic-1-12.svg" alt="Рис. 1.12. Пример несвязного графа" width="65%" />

Графы с несколькими компонентами связности успешно применяются при решении реальных прикладных задач. В качестве примера можно привести представление в виде графа системы магистральных шоссейных дорог (highway system), проложенных между штатами в США (можете объяснить, почему?).

Во многих прикладных задачах важно знать, содержит ли рассматриваемый граф циклы. Под ***циклом*** (cycle) понимается простой путь положительной длины, который начинается и заканчивается в одной и той же вершине. Например, в графе, изображенном на рис. 1.12, циклом является путь: `f, h, i, g, f`. Граф, не содержащий циклов, называют ***ациклическим*** (acyclic). Ациклические графы будут рассмотрены в следующем подразделе.

## Деревья

***Деревом*** (tree) (точнее, ***свободным деревом*** (free tree)) называется связный ациклический граф (рис 1.13а). Граф, который не содержит циклов, но не обязательно является связным, называется ***лесом*** (forest). Каждая компонента связности леса является деревом (рис. 1.13б).

<img src="pic-1-13.svg" alt="Рис. 1.13. Пример а) дерева и б) леса" width="65%" />

Деревья имеют несколько важных свойств, не присущих другим графам. В частности, число ребер в дереве всегда на единицу меньше, чем число его вершин:

<tex>|E| = |V| - 1</tex>

На примере графа, показанного на рис. 1.12, можно сделать вывод, что это свойство является необходимым, но не достаточным, чтобы граф был деревом. Тем не менее для связных графов это свойство является достаточным, поэтому с его помощью удобно определять, содержит ли граф цикл.

## Корневые деревья

Еще одним важным свойством деревьев является следующее: для любых двух вершин дерева существует только один простой путь от одной вершины к другой. Это свойство позволяет назначить произвольный узел в свободном дереве ***корнем*** root) и преобразовать свободное дерево в так называемое ***корневое дерево*** (rooted tree). Последнее обычно изображается так, чтобы его корень был вверху, т.е. располагался на так называемом нулевом уровне дерева. Ниже корня располагаются смежные с ним вершины. Они составляют первый уровень дерева. Вершины, соединенные с корнем двумя ребрами, составляют следующий (т.е. второй) уровень дерева, и т.д. На рис. 1.14 показано, как преобразовать свободное дерево в корневое.

<img src="pic-1-14.svg" alt="Рис. 1.14. Преобразование а) свободного дерева в б) корневое" width="80%" />

Корневые деревья играют в информатике гораздо более важную роль, чем свободные деревья. Поэтому часто для краткости их называют просто “деревьями”.
Их основное назначение — описание иерархических структур, таких как структура каталогов файловой системы или организационная структура предприятия.
Однако существуют и другие, менее очевидные области применения деревьев, например для организации словарей (об этом пойдет речь в следующем подразделе), для эффективного хранения очень больших массивов данных (см. раздел 7.4), для кодирования данных (см. раздел 9.4). Как вы увидите в главе 2, деревья также находят применение при анализе рекурсивных алгоритмов. И, чтобы закончить этот далеко не полный перечень возможных применений деревьев, следует упомянуть так называемые ***деревья пространств состояний*** (state-space trees). С их помощью можно объяснить два важных метода проектирования алгоритмов: поиск с возвратом (backtracking) и метод ветвей и границ (branch-and-bound). О них речь пойдет в разделах 11.1 и 11.2.

Для любой вершины `v` в дереве `T` верно следующее: все вершины, принадлежащие простому маршруту от корня дерева до этой вершины, называются ***предками*** (ancestors) `v`. Сама вершина `v` обычно считается собственным предком. Множество предков, в которое не включен собственный предок, называется множеством ***истинных предков*** (proper ancestors), или просто ***истинными предками***. Если `(u, v)` является последним ребром, принадлежащим простому маршруту, ведущему из корня дерева до вершины `v` (и <tex>u \\neq v</tex>), то говорят, что и является ***родителем*** (parent) `v`, a `v` называют ***потомком***, или ***дочерней*** (child) вершиной ***u***. Вершины, имеющие общего родителя, называются ***родственными***, или ***сестринскими*** (sibling). Вершина, у которой нет потомков, называется ***листом*** (leaf). Вершина, у которой есть как минимум один потомок, называется ***родительской*** (parental). Совокупность всех вершин, для которых вершина `v` является предком, называют ***потомками*** (descendants) `v`. Вершина `v` вместе со всем своими потомками называется ***поддеревом*** (subtree) дерева `T` с корнем (поддерева) в вершине `v`. Таким образом, для дерева, изображенного на рис. 1.14б, корнем является вершина `a`; вершины `d, g, f, h` и `i` являются листьями; вершины `a, b, e` и `c` являются родительскими. Родительской вершиной для `b` является вершина `a`; потомками вершины `b` являются вершины `c` и `g` родственными для `b` являются вершины `d` и `e`; вершинами поддерева с корнем в `b` являются: `{ b, c, g, h, i }`.

Под ***глубиной*** (depth) вершины `v` понимается длина простого пути от корня до этой вершины. Под ***высотой*** (height) дерева понимается длина наибольшего простого пути от его корня до одного из листьев. Например, в дереве, изображенном на рис. 1.14б, глубина вершины `c` равна `2`, а высота дерева равна `3`. Таким образом, если сосчитать уровни дерева сверху вниз, начиная с корня (ему соответствует нулевой уровень), то глубина вершины будет равна уровню этой вершины в дереве, а высота дерева будет соответствовать максимальному уровню, на котором могут находиться вершины в дереве. (Обратите внимание, что в некоторых книгах высота дерева определяется как количество уровней в дереве. При подобном определении высота дерева будет на единицу больше, чем высота, которая соответствует длине наибольшего простого маршрута от корня до одного из листьев.)

## Упорядоченные деревья

***Упорядоченным*** (ordered) называется такое корневое дерево, в котором упорядочены все потомки каждой вершины. Принято считать, что на диаграмме деревья изображаются так, чтобы все потомки были упорядочены слева направо. ***Двоичное (бинарное) дерево*** (binary tree) можно определить как упорядоченное дерево, каждая вершина которого имеет не более двух потомков, причем каждый из потомков считается либо ***левым*** (left child) либо ***правым*** (right child) потомком своего родителя. Поддерево, корень которого находится в левом (правом) потомке вершины, называется левым (правым) поддеревом этой вершины. Пример бинарного дерева показан на рис. 1.15а.

На рис. 1.15б вершинам бинарного дерева, показанного на рис. 1.15а, назначены числа. Обратите внимание, что число, которое назначено каждой родительской вершине, больше, чем число, назначенное ее левому потомку, и меньше, чем число, назначенное ее правому потомку. Деревья подобного типа называют ***бинарным деревом поиска*** (binary search trees). Бинарные деревья и бинарные деревья поиска находят широкое применение в информатике. С некоторыми из них вы столкнетесь при чтении этой книги. Бинарные деревья поиска являются частным случаем более общего типа деревьев поиска, которые называются ***многоканальными деревьями поиска*** (multiway search trees). Последние незаменимы при организации эффективного хранения на дисках файлов очень больших размеров.

<img src="pic-1-15.svg" alt="Рис. 1.15. Пример а) бинарного дерева и б) бинарного дерева поиска" width="75%" />

Ниже в этой книге мы покажем, что эффективность большинства основных алгоритмов, в которых используются бинарные деревья поиска и их вариации, непосредственно зависит от высоты дерева. Поэтому приведенное ниже неравенство для высоты бинарного дерева `h`, содержащего `n` вершин, особенно важно для анализа подобных алгоритмов:

<tex>\left\lfloor log_{2} n \right\rfloor \leqslant h \leqslant n - 1</tex>

При использовании в компьютерных программах бинарные деревья обычно реализуют в виде связанного списка, узлы которого соответствуют вершинам дерева. В каждый узел помещается информация о соответствующей ему вершине дерева (ее имя, присвоенное значение и т.д.), а также два указателя на его левого и правого потомка. На рис. 1.16 показана одна из подобных реализаций бинарного дерева поиска, показанного на рис. 1.15б.

Упорядоченное дерево в компьютере можно представить в виде родительской вершины с указателями на всех ее потомков. Однако такое представление не совсем удобно в том случае, когда количество потомков в процессе работы программы меняется в очень широких пределах. Чтобы избежать подобного неудобства, можно воспользоваться структурой данных, каждый узел которой будет иметь только два указателя (по аналогии с представлением бинарных деревьев). При этом левый указатель будет содержать ссылку на первого потомка текущей вершины, а правый — на следующую родственную ей вершину. Поэтому такое представление произвольного упорядоченного дерева называют ***“первый потомок — следующий родственник”*** (first child — next sibling). Таким образом, все родственные вершины будут связаны в один список с помощью правого указателя текущей вершины. При этом ссылка на первый элемент списка будет содержаться в левом указателе ее родителя. На рис. 1.17а показано подобное представление дерева, показанного на рис. 1.14б. Нетрудно заметить, что в результате подобного представления упорядоченное дерево оказалось преобразовано в бинарное. Поэтому говорят, что данное бинарное дерево ассоциировано с упорядоченным деревом.
Чтобы убедиться в этом, достаточно “развернуть” стрелки указателей по часовой стрелке примерно на 45°, как показано на рис 1.17б.

<img src="pic-1-16.svg" alt="Рис. 1.16. Типовая реализация бинарного дерева поиска, показанного на рис. 1.15б" width="65%" />

<img src="pic-1-17.svg" alt="Рис. 1.17. а) Представление графа, показанного на рис. 1.14б в виде структуры “первый потомок — следующий родственник”; 6) ассоциированное с ним бинарное дерево" width="95%" />

## Множества и словари

Понятие множества играет основную роль в математике. ***Множество*** (set) можно охарактеризовать как неупорядоченную совокупность (которая может быть пуста) отдельных элементов, называемых элементами множества. Конкретное множество определяется либо в виде явного списка элементов (например, `S = { 2,3,5,7 }`), либо в виде указания условия, которому должны удовлетворять все элементы множества и только они (например, `S = { n, где n — простое число, меньшее 10 }`). Основными операциями над множествами являются: проверка на членство в данном множестве (т.е. принадлежит ли элемент множеству; другими словами, нужно найти заданный элемент среди элементов множества), поиск объединения двух множеств (т.е. формирование нового множества, элементы которого принадлежат либо первому, либо второму множеству, либо обоим множествам одновременно), а также поиск пересечения двух множеств (т.е. формирование нового множества, элементы которого принадлежат только обоим множествам одновременно).

При разработке компьютерных приложений множества можно реализовать двумя способами. В первом случае рассматриваются только множества, которые являются подмножествами некоторого большого множества `U`, называемого ***универсальным множеством***, или ***универсумом*** (universal set). Если множество `U` состоит из `n` элементов, то любое его подмножество `S` можно представить в виде строки из `n` битов, называемой ***битовым вектором*** (bit vector), в которой `i`-й элемент равен `1` тогда и только тогда, когда `i`-й элемент множества `U` включен в подмножество `S`. Поэтому, возвращаясь к нашему примеру, если `U = { 1, 2, 3, 4, 5, 6, 7, 8, 9}`, то подмножество `S = { 2, 3, 5, 7 }` можно представить в виде битовой строки `011010100`. Описанный способ представления множеств позволяет реализовать стандартный набор операций над множеством в виде очень быстрых процедур. Однако платой за скорость является большой объем оперативной памяти, необходимой для представления элементов множества<n>В нашей книге это первый пример компромисса между временем выполнения алгоритма и требуемым объемом оперативной памяти. Более подробно мы поговорим об этом в главе 7.</n>.

Чаще всего в компьютерных программах используется второй способ представления множества. Он заключается в представлении элементов множества в виде связанного списка. Само собой разумеется, речь идет о представлении только конечных множеств. К счастью, в отличие от математики, данный вид множеств наиболее широко используется в компьютерных приложениях. Тем не менее необходимо обратить внимание на два принципиальных различия между множествами и списками. Во-первых, в множестве не может быть одинаковых элементов, а в списке — может. Иногда это требование к уникальности элементов обходят путем введения так называемого ***мультимножества*** (multiset), или ***пакета*** (bag), т.е. неупорядоченной совокупности элементов, которые необязательно должны быть различными. Во-вторых, поскольку множество — это неупорядоченная совокупность элементов, изменение порядка его элементов не изменяет само множество. В свою очередь, список определяется как упорядоченная совокупность элементов, что в корне противоположно понятию множества. Выше мы перечислили важные теоретические различия между множеством и списком, однако, к счастью, они не так важны для большинства приложений. Кроме того, стоит упомянуть, что в том случае, когда множество представляется в виде списка, то для ряда приложений имеет смысл поддерживать его в отсортированном виде.

В прикладных программах над множеством или мультимножеством чаще всего выполняются следующие операции: поиск заданного элемента, добавление нового элемента и удаление элемента из совокупности. Структуру данных, задействованную в реализации трех этих операций, называют ***словарем*** (dictionary). Заметим, что о взаимосвязи этой структуры данных с задачами поиска говорилось выше в разделе 1.3. Очевидно, что здесь речь идет о выполнении поиска в динамически изменяемом контексте. Поэтому эффективная реализация словаря должна быть результатом достижения компромисса между эффективным выполнением поиска и двух других операций над множеством. В действительности существует несколько способов реализации словаря. Они могут быть как очень простыми, с использованием обычных массивов сортированных (или несортированных) элементов, так и довольно сложными. В последнем случае используются методы хеширования и сбалансированные деревья поиска, которые будут описаны в последующих главах этой книги.

При решении ряда прикладных задач из области вычислительной техники нужно динамически разбить множество, состоящее из `n` элементов, на ряд непересекающихся подмножеств. После инициализации множества как набора из `n` одноэлементных подмножеств задача сводится к последовательности операций поиска и объединения. Эта задача называется задачей ***объединения множества*** (set union). Эффективные алгоритмы решения этой задачи будут описаны в разделе 9.2 при рассмотрении одного из важных ее применений.

Вы, наверное, уже заметили, что в приведенном выше обзоре основных структур данных мы почти всегда упоминали об особенностях операций, которые обычно выполняются над рассматриваемыми структурами данных. Подобную тесную взаимосвязь между структурами данных и выполняемыми над ними операциями специалисты в области информатики заметили уже давно. Это навело их на мысль о существовании так называемых ***абстрактных типов данных*** (abstract data type, или ***ADT***) т.е. множества абстрактных объектов, представляющих элементы данных, и определенного на нем набора операций, которые могут быть выполнены над элементами этого множества. В качестве иллюстрации этого понятия перечитайте, например, приведенные выше определения приоритетной очереди и словаря. Несмотря на то что абстрактные типы данных можно реализовать с помощью старых процедурных языков программирования, таких как Pascal (в качестве примера см. [5]), все-таки намного удобнее делать это с помощью объектно-ориентированных языков программирования, таких как C++ или Java, в которых абстрактные типы данных поддерживаются с помощью ***классов*** (classes).