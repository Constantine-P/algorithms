# Понятие алгоритма

Что же такое алгоритм? Универсального определения этого понятия нет, однако существует общее мнение по поводу того, что оно должно означать:

<def>Алгоритм — это последовательность четко определенных инструкций, предназначенных для решения некоторой задачи. Другими словами, это последовательность команд, позволяющих получить из корректных входных данных требующиеся выходные данные за ограниченный промежуток времени.</def>

Это определение можно проиллюстрировать с помощью простой схемы.

![Рисунок 1.1. Иллюстрация понятия алгоритма](pic-1-01.svg)

Упомянув в приведенном выше определении слово “инструкции”, мы подразумевали, что существует некоторое абстрактное устройство (или человек), способное распознать эти инструкции и выполнить предписываемые ими действия. На рис. 1.1 это устройство названо “вычислительным”. Однако следует иметь в виду, что до появления компьютеров под термином “вычислительное устройство” понимался человек, выполняющий числовые расчеты. Естественно, если речь идет о современности, под словом “вычислительное устройство” понимается компьютер, то есть популярное электронное устройство, которое практически повсеместно вторглось в нашу жизнь. Тем не менее обратите внимание на то, что, хотя большая часть алгоритмов в конечном счете предназначена для реализации на компьютере, само понятие алгоритма никак не связано с этим допущением.

В этом разделе в качестве примеров, иллюстрирующих понятие алгоритма, мы рассмотрим три способа решения одной и той же задачи — поиска НОД двух целых чисел. Эти примеры помогут нам проиллюстрировать перечисленные ниже важные моменты.

- Каждый шаг алгоритма должен быть четко и однозначно определен. Это требование является обязательным и не должно нарушаться ни при каких обстоятельствах.
- Должны быть точно указаны диапазоны допустимых значений входных данных, которые обрабатываются с помощью алгоритма.
- Один и тот же алгоритм можно представить несколькими разными способами.
- Для решения одной и той же задачи может существовать несколько разных алгоритмов.
- В основу алгоритмов для решения одной и той же задачи могут быть положены совершенно разные принципы, что может существенно повлиять на скорость решения этой задачи.

Обозначим функцию поиска НОД двух неотрицательных целых чисел `m` и `n` (причем `m` и `n` не могут одновременно равняться нулю) через `gcd(m, n)`.<n>От английского "greatest common divisor"</n> По определению эта функция должна найти наибольшее целое число, которое делится без остатка как на `m`, так и на `n`. Древнегреческий математик Евклид из Александрии (III век до н.э.), который 
прославился тем, что впервые систематически изложил курс геометрии, описал алгоритм решения этой задачи в одном из своих трудов под названием *Начала*. Выражаясь современным языком, *алгоритм Евклида* основан на рекуррентном вычислении следующего равенства:

`gcd (m, n) = gcd (n, m mod n).`

Здесь выражение (`m mod n`) является остатком от деления `m` на `n`. Выполнение алгоритма заканчивается, когда выражение (`m mod n`) становится равным нулю. Поскольку `gcd(m, 0) = m` (понятно, почему?), последнее полученное значение `m` будет также являться НОД исходных чисел `m` и `n`.

Например, вычисление НОД пары чисел `(60, 24)` можно выполнить следующим образом:

`gcd (60, 24) = gcd (24, 12) = gcd (12, 0) = 12.`

(Если этот алгоритм не произвел на вас впечатления, попытайтесь определить НОД двух больших чисел, например таких, которые используются в задаче 4 упражнения 1.1.)

Ниже приводится более структурированное описание рассматриваемого нами алгоритма.

### Вычисление НОД чисел `m` и `n` при помощи алгоритма Евклида

- Шаг 1. Если `n = 0`, вернуть `m` в качестве ответа и закончить работу; иначе перейти к шагу 2. 
- Шаг 2. Поделить нацело `m` на `n` и присвоить значение остатка переменной `r`. 
- Шаг 3. Присвоить значение `n` переменной `m`, а значение `r` — переменной `n`. Перейти к шагу 1. 

В качестве альтернативы запишем тот же алгоритм в виде псевдокода.

<table>
  <thead>
    <tr>
      <th colspan="2">
        Алгоритм <code>Euclid (m, n)</code>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td colspan="2">
        Алгоритм Евклида вычисляет значение функции <code>gcd (m, n)</code>
      </td>
    </tr>
    <tr>
      <td>
        Входные данные
      </td>
      <td>
        два неотрицательных целых числа <code>m</code> и <code>n</code>, которые не могут одновременно быть равны нулю
      </td>
    </tr>
    <tr>
      <td style="white-space: nowrap">
        Выходные данные
      </td>
      <td>
        наибольший общий делитель чисел <code>m</code> и <code>n</code>
      </td>
    </tr>
  </tbody>
</table>

```javascript showLineNumbers
function gcd(m, n) {
  while(n !== 0) {
    const r = m % n;
    m = n;
    n = r;
  }
  return m;
}
```

Можем ли мы убедиться, что в конечном счёте выполнение алгоритма Евклида завершится? Это следует из констатации следующего факта: на каждом шаге итерации значение второго числа пары (`n`) будет уменьшаться, причем, по определению, оно не может быть меньше нуля. В самом деле, новое значение числа `n`, получаемое на следующей итерации в результате вычисления выражения (`m mod n`), будет всегда 
меньше, чем предыдущее значение числа `n`. Следовательно, рано или поздно значение второго числа пары станет равным `0`, и выполнение алгоритма завершится. 

Как и при решении большинства других задач, существует несколько алгоритмов вычисления НОД. Давайте рассмотрим два других способа решения этой задачи. Первый из них основан на подборе наибольшего целого числа — такого, чтобы числа `m` и `n` делились на него без остатка. Очевидно, что такой общий делитель не может быть больше наименьшего из чисел пары, которое можно записать как `t = min {m, n}`. 
Поэтому выполнение алгоритма можно начать с проверки того, делятся ли оба числа, `m` и `n`, на `t` без остатка. Если это так, то число `t` является ответом; если нет, нужно уменьшить значение `t` на единицу и снова выполнить проверку. (Можем ли мы убедиться, что в конечном итоге этот процесс завершится?). Например, для рассмотренной выше пары чисел `(60, 24)`, выполнение алгоритма начинается с 
проверки числа `24`, затем — `23` и так далее до тех пор, пока значение числа `t` не станет равным `12`, после чего алгоритм должен завершить свою работу.

### Вычисление НОД чисел `m` и `n` методом последовательного перебора

- Шаг 1. Присвоить значение функции `min {m, n}` переменной `t`.
- Шаг 2. Разделить `m` на `t`. Если остаток равен нулю, перейти к шагу 3; иначе перейти к шагу 4.
- Шаг 3. Разделить `n` на `t`. Если остаток равен нулю, вернуть `t` в качестве ответа и закончить работу; иначе перейти к шагу 4.
- Шаг 4. Вычесть `1` из `t`. Перейти к шагу 2.

Обратите внимание, что в отличие от алгоритма Евклида, рассматриваемый нами алгоритм поиска НОД в описанной выше форме не будет корректно работать, если хотя бы один из его входных параметров равен нулю. Таким образом, этот пример позволяет показать, почему так важно явно определять диапазоны допустимых значений входных параметров алгоритма.

Третий способ поиска НОД должен быть вам знаком из курса средней школы.

### Вычисление НОД чисел `m` и `n` “школьным” методом

- Шаг 1. Разложить на простые множители число `m`.
- Шаг 2. Разложить на простые множители число `n`.
- Шаг 3. Для простых множителей чисел `m` и `n`, найденных на шаге 1 и 2, выделить их общие делители. (Если `р` является общим делителем чисел `m` и `n` и встречается в их разложении на простые множители, соответственно, <tex>p_{m}</tex> и <tex>p_{n}</tex> раз, то при выделении нужно повторить это <tex>min \\ \\{ p_{m}, p_{n} \\}</tex> раз.)
- Шаг 4. Вычислить произведение всех выделенных общих делителей и вернуть его в качестве результата поиска НОД двух указанных чисел.

Таким образом, для рассмотренной выше пары чисел `(60, 24)`, получим:

```tex
  60 = 2  \cdot 2  \cdot 3  \cdot 5 \\
  24 = 2  \cdot 2  \cdot 2  \cdot 3 \\
  gcd \ (60, 24) = 2  \cdot 2  \cdot 3 = 12.
```

Ностальгия по школьным годам не должна помешать нам сделать вывод о том, что последний из рассмотренных способов поиска НОД гораздо сложнее и медленнее, чем алгоритм Евклида. (Методы определения и сравнения времени выполнения алгоритмов будут описаны в следующей главе.) Но даже не принимая во внимание его низкую эффективность, метод определения НОД, изучаемый в средней школе, нельзя считать законным алгоритмом (по крайней мере в представленном здесь виде). Вы спросите, почему? Все дело в том, что этапы разложения на простые множители не определены однозначно. Для их выполнения требуется иметь список простых чисел, а я почему-то уверен, что школьный учитель не объяснил вам, как составить такой список. Вы, конечно же, можете возразить, что это не повод для подобных придирок. Однако до тех пор, пока этот момент не будет прояснен, мы не сможем, например, написать на каком-либо из языков программирования программу, реализующую этот алгоритм. (Кстати, с этой точки зрения шаг 3 также недостаточно четко определен. Однако его неопределенность гораздо легче прояснить, чем этапы разложения на простые множители. И еще, как вы собираетесь выделять общие элементы из двух списков?)

Итак, подошло время рассмотреть несложный алгоритм генерации последовательности простых чисел, не превышающих произвольно заданного целого числа `n`. Вероятнее всего он был придуман в древней Греции и поэтому назван решетом Эратосфена <n>Примерно 200 год до н.э.</n>. Для начала составим список, содержащий последовательность целых чисел от `2` до `n`, из которого затем мы должны будем 
выбрать 
простые числа.
Далее, на первом проходе алгоритма нужно удалить из списка все числа, которые делятся на `2`, т.е. `4`, `6` и т.д. Затем необходимо выбрать из списка следующий элемент (в данном случае это `3`) и удалить из списка все числа, которые делятся на него. (В описываемой простой версии алгоритма существует небольшая накладка, поскольку некоторые из чисел, например `6`, должны удаляться из списка более одного раза.) Для числа `4` не нужно выполнять специальный проход по списку, так как число `4` кратно `2`, поэтому оно уже будет удалено из списка на первом проходе. (Точно так же в этом алгоритме не нужно выполнять проход и для всех других чисел, которые были удалены из списка на предыдущих проходах). Следующим числом, которое осталось в списке и используется на третьем проходе, является `5`. Работа алгоритма продолжается так до тех пор, пока в списке существуют числа, которые можно удалить. Числа, оставшиеся в списке после выполнения алгоритма, являются простыми.

В качестве примера использования, описанного выше алгоритма, рассмотрим процесс поиска простых чисел, не превышающих `n = 25`:

```dsconfig
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
2 3   5   7   9    11    13    15    17    19    21    23    25
2 3   5   7        11    13          17    19          23    25
2 3   5   7        11    13          17    19          23      
```

Для нашего примера не требуется большего количества проходов по списку, поскольку из него на рассмотренных проходах были удалены все составные числа. Таким образом, в списке остались только упорядоченные простые числа, меньшие или равные `25`.

Возникает общий вопрос: при каком наибольшем значении числа `р` в списке еще остаются кратные ему числа? Прежде чем ответить на него, заметим, что, если `р` является числом, кратные которому числа должны быть удалены из списка на текущем проходе, то начать рассмотрение следует с числа <tex>p \times p</tex>, поскольку все меньшие кратные ему числа — `2р, ... , (р - 1)р` — уже были удалены из 
списка на предыдущих проходах. Это наблюдение позволит избежать удаления из списка одного и того же числа более одного раза. Очевидно, что <tex>p \times p</tex> не должно быть больше, чем `n`, поэтому `р` не может превышать значения <tex>\sqrt{n}</tex>, округленного до целого числа в нижнюю сторону. На математическом языке это записывается как <tex>\left\lfloor \sqrt{n} \right\rfloor</tex>, т.е. с помощью так
называемой функции “пол” (округления вниз, floor). В приведенном ниже псевдокоде алгоритма предполагается, что для вычисления используется готовая функция <tex>\left\lfloor \sqrt{n} \right\rfloor</tex>. Как альтернативный вариант можно в качестве условия продолжения вычисления цикла проверять значение неравенства <tex>p \times p \leqslant n</tex>.

<table>
  <thead>
    <tr>
      <th colspan="2">
        Алгоритм <code>Sieve (n)</code> (решето Эратосфена)
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td colspan="2">
        Реализация решета Эратосфена
      </td>
    </tr>
    <tr>
      <td>
        Входные данные
      </td>
      <td>
        Положительное целое число <tex>n \geqslant 2</tex>
      </td>
    </tr>
    <tr>
      <td style="white-space: nowrap">
        Выходные данные
      </td>
      <td>
        Массив <code>L</code> простых чисел, меньших или равных <code>n</code>
      </td>
    </tr>
  </tbody>
</table>

```javascript showLineNumbers
function sieve(n) {
  const A = [];
  const L = [];
  for (let p = 2; p <= n; p++) {
    A[p] = p;
  }
  for (let p = 2; p <= Math.floor(Math.sqrt(n)); p++) {
    if (A[p] !== 0) {
      let j = p * p;
      while (j <= n) {
        A[j] = 0;
        j = j + p;
      }
    }
  }
  let i = 0;
  for (let p = 2; p <= n; p++) {
    if (A[p] !== 0) {
      L[i] = A[p];
      i = i + 1;
    }
  }
  return L;
}
```

Итак, теперь можно объединить алгоритм решета Эратосфена с методом, который вы проходили в средней школе, получив совершенно законный алгоритм поиска НОД двух положительных чисел. Обратите внимание, что в этом алгоритме нужно предусмотреть частный случай, когда один или оба входных параметра равны `1`. Поскольку математики не считают число `1` простым, то, строго говоря, этот метод и не должен работать в подобном случае.

Прежде чем закончить этот раздел, необходимо сделать еще одно важное замечание. Примеры, рассмотренные в этом разделе, не относятся к математическим задачам, несмотря на то, что большинство этих алгоритмов широко используются, а некоторые даже реализованы в виде компьютерных программ. Умение раскладывать задачи на алгоритмы пригодится в решении повседневных рутинных проблем, возникающих как на работе, так и дома. Вполне возможно, что, осознав важность алгоритмов в современном мире, вам захочется еще больше узнать об этом замечательном двигателе информационного века.