# Основы решения алгоритмической задачи

Начнем этот раздел с повторения важного вывода, сделанного во введении к этой главе:

Алгоритмы можно считать процедурным решением задач.

Причем эти решения являются не столько ответами, сколько точно определенными инструкциями для получения ответов. Именно этот акцент на точности определения конструктивных процедур отличает информатику от других дисциплин, в частности от теоретической математики, в которой обычно ограничиваются доказательством существования решения и (иногда) исследованиями характеристик решения.

А теперь перечислим и кратко опишем последовательность этапов проектирования и анализа алгоритмов.

<img src="pic-1-02.svg" alt="Рис. 1.2. Процесс проектирования и анализа алгоритма" width="40%" />

## Понимание задачи

С практической точки зрения, прежде чем заняться проектированием алгоритма, необходимо полностью понять поставленную перед вами задачу. Прочтите внимательно условие задачи и задайте вопросы, если вы чего-то не поняли. Просчитайте вручную несколько небольших примеров, продумайте частные случаи и при необходимости снова задайте вопросы.

Существует несколько типов задач, которые при создании компьютерных приложений встречаются чаще всего. Их обзор будет сделан в следующем разделе. Если перед вами поставлена одна из этих задач, для ее решения можно воспользоваться известным алгоритмом. Конечно, в процессе решения необходимо понять, как работает алгоритм, и оценить все его достоинства и недостатки, особенно если существует возможность выбора среди нескольких алгоритмов. Однако чаще всего вы не сможете найти подходящий готовый алгоритм и должны будете создать собственный. Описанная в этом разделе последовательность этапов поможет вам в этом захватывающем, но не всегда легком деле.

Входные данные, обрабатываемые алгоритмом, определяют экземпляр задачи (problem’s instance), решаемой с помощью выбранного алгоритма. При этом очень важно точно указать границы примеров, которые должны учитываться в алгоритме. (Вспомните, насколько отличаются границы примеров для трех алгоритмов поиска НОД, рассмотренных в предыдущем разделе). Если этого не сделать, то алгоритм будет прекрасно работать для большинства значений входных параметров, однако при подстановке отдельных “граничных” значений вы получите некорректные результаты. Позвольте напомнить, что корректным считается такой алгоритм, который выдает абсолютно правильный результат для всех (а не только для большинства!) заранее оговоренных значений входных данных.

Не стоит недооценивать первый этап процесса решения алгоритмической задачи, поскольку в противном случае, как правило, приходится многое переделывать.

## Определение возможностей вычислительного устройства

Полностью уяснив суть поставленной задачи, необходимо оценить возможности вычислительного устройства, для которого создается алгоритм. Подавляющее большинство современных алгоритмов предназначено для создания на их основе программы, работающей на компьютере, сильно напоминающем по структуре машину фон Неймана<n>Речь идет о структуре вычислительного устройства, описанного выдающимся американским математиком венгерского происхождения Джоном фон Нейманом (John von Neumann) (1903-1957) в сотрудничестве с А. Барксом (A. Burks) и Г. Голдстином (Н. Goldstine) в 1946 году</n>. Суть этой архитектуры выражена в ее названии — машина с произвольным доступом (random-access machine, или RAM). Предполагалось, что команды должны последовательно выбираться из памяти и выполняться специальным устройством, называемым центральным процессором, причем в каждый момент времени в машине Неймана могла выполняться только одна команда. Поэтому алгоритмы, разработанные для выполнения на такой машине, назвали последовательными (sequential algorithms).

Появление машины Неймана не могло остановить прогресс в области вычислительной техники. Вскоре были придуманы компьютеры, которые могли одновременно (т.е. параллельно) выполнять несколько команд. Поэтому алгоритмы, разработанные для таких машин, назвали параллельными (parallel algorithms). Тем не менее изучение классических методов проектирования и анализа алгоритмов для машины Неймана еще долго будет оставаться краеугольным камнем алгоритмики.

Задумывались ли вы когда-нибудь о том, насколько быстро ваш компьютер выполняет команды и какой у него объем оперативной памяти? Наверняка вы ответите “нет”, если до этого проектировали алгоритмы лишь с теоретической точки зрения. Как будет показано в разделе 2.1, большинство кибернетиков предпочитают изучать алгоритмы, не привязываясь к параметрам конкретной компьютерной системы. Ответ специалиста-практика наверняка будет зависеть от того, какую задачу перед ним поставили. Даже “медленные” по современным меркам компьютеры на деле оказываются невероятно быстродействующими. Следовательно, проблема “медленного компьютера” не должна возникать для большинства решаемых вами задач. Однако существует целый класс важных задач, которые по своей природе являются очень сложными, должны обрабатывать огромные массивы данных или работать в жестких временных рамках. В подобных ситуациях непременно следует учитывать быстродействие компьютерной системы, на которой будет работать реализация алгоритма, и доступный объем оперативной памяти.

## Выбор между точным или приближенным методом решения задачи

Следующий принципиальный вопрос — выбор точного или приближенного метода решения задачи. В первом случае алгоритм называется точным (exact algorithm), а во втором — приближенным (approximation algorithm). Почему для решения задачи иногда выбираются приближенные алгоритмы? Во-первых, существуют задачи, которые нельзя решить точно. В качестве примера можно привести извлечение квадратного корня, 
решение нелинейных уравнений или вычисление определенных интегралов. Во-вторых, существующие алгоритмы для точного решения задачи могут быть недопустимо медленными, если ее сложность достаточно высока. Наиболее известной из таких задач является задача коммивояжера (traveling salesman problem), которая заключается в поиске кратчайшего маршрута между `n` городами. В главах 3, 10 и 11 будут 
приведены и другие примеры подобных задач. В-третьих, приближенный алгоритм может являться частью другого, более сложного алгоритма, с помощью которого задача решается точно.

## Выбор подходящих структур данных

В некоторых алгоритмах не требуется, чтобы входные данные были представлены в каком-то специфическом формате. Однако так бывает не всегда, более того, для работы многих алгоритмов требуются совершенно определенные структуры данных. Кроме того, некоторые из методов проектирования алгоритмов, о которых пойдет речь в главах 6 и 7, очень тесно связаны со структуризацией и реструктуризацией данных, определяющих экземпляры задачи. Много лет назад в уважаемой всеми книге провозглашалась чрезвычайная важность алгоритмов и структур данных и их влияние на процесс программирования. Причем об этой важности говорило само за себя название этой книги: Algorithms + Data Structures = Programs [123]. В современном мире, где властвует объектно-ориентированное программирование, структуры данных остаются чрезвычайно важным элементом процесса проектирования и анализа алгоритмов. Обзор основных структур данных будет сделан в разделе 1.4.

## Методы проектирования алгоритмов

Теперь, когда все составляющие решения алгоритмической проблемы находятся на своих местах, остается выяснить, как нужно проектировать алгоритмы решения поставленных перед вами задач. Это основной вопрос данной книги. Для ответа на него вам предлагается изучить несколько общих методов проектирования алгоритмов. Что же такое метод проектирования алгоритма?

<def>
Метод проектирования алгоритма (algorithm design technique) (или “стратегия”, или “принцип”) — это универсальный подход, применяемый для алгоритмического решения широкого круга задач, относящихся к различным областям вычислительной техники.
</def>

Взглянув на оглавление этой книги, вы поймете, что основная часть ее глав посвящена именно отдельным методам проектирования алгоритмов. В них излагается несколько проверенных временем ключевых идей, используемых при разработке алгоритмов. Изучение этих методов в высшей степени важно по следующим причинам.
Во-первых, они обеспечивают набор универсальных принципов, руководствуясь которыми можно разработать алгоритмы решения новых задач, т.е. таких задач, для решения которых еще не существует достаточно хороших алгоритмов.
Поэтому, перефразируя известную поговорку, можно сказать, что изучение подобных методов сродни подаренной удочке, а не предложенной рыбе. Конечно, не все из этих универсальных методов подойдут для решения практических задач, с которыми вам предстоит столкнуться. Однако они представляют собой мощный набор средств, которые пригодятся вам в учебе и работе.

Во-вторых, алгоритмы являются краеугольным камнем информатики. Классификация основополагающих понятий важна для любой науки, и информатика не является исключением. Изучение этих методов позволяет классифицировать алгоритмы согласно лежащему в их основе принципу проектирования. Поэтому они как нельзя лучше подходят и для классификации, и для изучения алгоритмов.

## Методы представления алгоритмов

После того как алгоритм спроектирован, нужно представить его в каком-либо виде. В разделе 1.1 в качестве примера мы описали алгоритм Евклида — как словами (т.е. в свободной форме в виде последовательности выполняемых действий), так и в виде псевдокода. В наши дни для представления алгоритмов чаще всего используются эти две формы.

Безусловно, использование естественного языка для описания алгоритма имеет очевидное преимущество. Тем не менее присущая любому такому языку неопределенность иногда затрудняет лаконичное и понятное описание алгоритмов. Как бы то ни было, умение словесно описать алгоритм в процессе его изучения никогда не будет лишним.

**Псевдокод** (pseudocode) представляет собой смесь одного из естественных языков<n>Чаще всего английского, хотя встречаются случаи использования в псевдокоде русского языка</n> и конструкций, характерных для языка программирования. Описание алгоритма на псевдокоде обычно является более точным по сравнению с естественным языком. Кроме того, в результате его использования часто получается более 
компактная запись алгоритма. Неожиданностью является то, что специалисты до сих пор так и не приняли какую-либо форму псевдокода в качестве стандарта. Поэтому в разных книгах можно встретить различные “диалекты” этого языка. К счастью, эти диалекты настолько близки, что любой человек, владеющий каким-либо современным языком программирования, сможет без особого труда в них разобраться.

Используемый в этой книге диалект псевдокода не должен представлять особых затруднений для читателя. Ради простоты изложения мы опустили операторы определения переменных, а для обозначения области действия таких операторов, как `for`, `if` и `while`, в тексте псевдокода использованы отступы. Как вы уже, наверное, заметили при чтении предыдущего раздела, для обозначения операции присваивания мы 
используем стрелку, а комментариев — две косые черты подряд.

На заре развития вычислительной техники основным способом представления алгоритмов были блок-схемы (flowchart), т.е. чертежи, состоящие из последовательности соединенных стрелками геометрических фигур, с помощью которых описывался каждый шаг выполнения алгоритма (примером может служить рис. 1.2). Однако подобный способ представления сочли неудобным, особенно в случае больших и сложных алгоритмов, поэтому в современной литературе он не используется.

Современные средства вычислительной техники еще не достигли такого уровня, чтобы описание алгоритма (будь-то его словесное описание или псевдокод) можно было непосредственно ввести в компьютер. Поэтому пока приходится вручную преобразовывать алгоритмы в компьютерные программы и записывать их на одном из доступных языков программирования. Таким образом, подобную программу можно считать еще одним средством представления алгоритма, хотя, строго говоря, программа является реализацией конкретного алгоритма.

## Оценка корректности алгоритма

После представления алгоритма в какой-либо форме, необходимо оценить его корректность (correctness). Это означает, что вы должны доказать, что выбранный алгоритм за ограниченный промежуток времени выдает требуемый результат для любых корректных значений входных данных. Например, корректность алгоритма Евклида для вычисления НОД двух чисел, `m` и `n` , следует из правильности равенства `gcd (m, n) 
= gcd (n, m mod n)`, которое, в свою очередь, должно быть доказано (см. упражнение 1.1.5), а также из простого наблюдения, что второе число на каждой итерации будет все время уменьшаться, и по достижении им нуля, выполнение алгоритма прекращается.

Доказать корректность одних алгоритмов очень легко, других — невероятно сложно. Универсальным методом доказательства корректности алгоритма считается метод математической индукции. Дело в том, что алгоритмы по своей природе являются итеративными и описываются в виде последовательности пошаговых инструкций, которые как раз и используются при доказательстве методом индукции. Стоит отметить, что, хотя отслеживание быстродействия алгоритма с помощью нескольких наборов тщательно подобранных входных данных приводит к очень полезным результатам, подобную проверку нельзя считать убедительной при доказательстве корректности алгоритма. Однако доказательством некорректной работы алгоритма может служить лишь один набор входных данных, при обработке которых получается неправильный результат. Если некорректная работа алгоритма будет доказана, придется либо несколько видоизменить его, не выходя за рамки принятых структур данных, методов проектирования и т.п., либо решать проблему более кардинально, пересмотрев принятые ранее принципы и подходы (см. рис. 1.2).

Оценка корректности приближенных алгоритмов менее тривиальна, чем их точных аналогов. При этом нужно показать, что погрешность получаемых в результате работы алгоритма выходных данных не превышает заранее установленных пределов. Примеры подобных оценок приведены в главе 11.

## Анализ алгоритма

Обычно создатели алгоритмов стараются, чтобы они удовлетворяли нескольким требованиям. После проверки корректности алгоритма одной из самых важных характеристик является оценка его эффективности. На практике существует два вида оценки эффективности алгоритма: временная и пространственная. Временная эффективность (time efficiency) является индикатором скорости работы алгоритма. Что касается пространственной эффективности (space efficiency), то эта оценка показывает количество дополнительной оперативной памяти, необходимой для работы алгоритма. Общая идея и конкретные методы анализа эффективности алгоритмов будут рассмотрены в главе 2.

Еще одной важной характеристикой алгоритма является его простота (simplicity). В отличие от эффективности, которую можно точно определить и оценить с помощью строгих математических выражений, простота алгоритма чем-то напоминает человеческую красоту, понятие которой настолько субъективно, что выработать объективные критерии ее оценки весьма непросто. Например, большинство людей считают, что алгоритм Евклида поиска НОД двух чисел проще, чем тот, которому нас учили в школе, но это вовсе не означает, что он понятнее. В то же время алгоритм Евклида проще алгоритма последовательного перебора целых чисел. Тем не менее простота является важной характеристикой алгоритма, и к ней нужно стремиться. Вы спросите, почему? Дело в том, что простые алгоритмы легче понять и запрограммировать. Следовательно, в полученной программе будет содержаться меньше ошибок. Кроме того, в простоте существует неоспоримая эстетическая привлекательность. Ну и наконец, простые алгоритмы зачастую более эффективны, чем их сложные аналоги. К сожалению, последнее утверждение не всегда выполняется. В подобных случаях необходимо руководствоваться здравым смыслом и принимать компромиссные решения.

Следующей важной характеристикой алгоритма является его общность, или универсальность (generality). По сути, здесь можно выделить два момента: общность задачи, для решения которой разработан алгоритм, и диапазон допустимых значений его входных данных. По поводу первого замечания следует сказать, что иногда легче разработать алгоритм для решения общей задачи, чем заниматься поиском решения ее 
частного случая. В качестве примера рассмотрим такую задачу: определить, являются ли два целых числа взаимно простыми. Напомним, что два числа считаются взаимно простыми, если у них нет общих делителей, кроме `1`. В данном случае легче разработать алгоритм для решения общей задачи вычисления НОД двух целых чисел. Затем, чтобы решить исходную задачу, достаточно подставить заданные числа в 
функцию `gcd` и проверить, равно ли ее значение `1`. Однако бывают случаи, когда разработка более общего алгоритма нежелательна, затруднена или даже невозможна. Например, излишне выполнять сортировку всего списка, содержащего `n` чисел, чтобы определить их медиану, поскольку достаточно просто найти значение `m`-го наименьшего элемента, где <tex>\left\lceil m = \frac{n}{2} \right\rceil</tex>. Еще один пример: известно, что стандартную формулу для поиска корней квадратного уравнения нельзя обобщить для поиска корней полиномов более высоких степеней.

Что касается диапазона допустимых значений входных данных алгоритма, то здесь нужно отметить следующее. При разработке алгоритма нужно учитывать, что диапазон изменения значений входных параметров может колебаться в очень широких пределах и должен естественным образом соответствовать решаемой задаче. Например, неестественно в алгоритме поиска НОД исключать из рассмотрения значения входных параметров, равные `1`. С другой стороны, хотя стандартную формулу корней квадратного уравнения можно использовать и в случае комплексных коэффициентов, при принятом уровне обобщения этот случай исключают из рассмотрения, поскольку он должен оговариваться отдельно.

Если вас не устраивает эффективность, простота или общность алгоритма, придется снова взять в руки карандаш и перепроектировать алгоритм. И даже если анализ алгоритма привел к положительным результатам, имеет смысл поискать другое алгоритмическое решение задачи. Достаточно вспомнить три алгоритма определения НОД, рассмотренных в предыдущем разделе. Вообще говоря, не стоит надеяться, что вы с первой попытки найдете оптимальное решение задачи. Самое меньшее, что можно сделать, попытаться оптимизировать созданный алгоритм. Например, мы внесли несколько улучшений в реализацию алгоритма решета Эратосфена, по сравнению с той, что была описана в разделе 1.1. (Можете ли вы назвать их не задумываясь?) Всегда помните высказывание Антуана де Сент-Экзюпери (Antoine de Saint-Exupery), известного французского писателя, летчика и авиаконструктора:
> Конструктор достигает совершенства не тогда, когда ему больше нечего добавить к своему детищу, а тогда, когда больше нечего удалить.
<n>Я обнаружил это высказывание по поводу простоты конструкции в сборнике рассказов Джона Бентли (Jon Bentley) [15]. Этот сборник посвящен особенностям проектирования и реализации алгоритмов и имеет совершенно логичное название Programming Pearls [15]. Настоятельно рекомендую почитать рассказы Бентли и Сент-Экзюпери. Не пожалеете!</n>
 
## Кодирование алгоритма

Большинство алгоритмов рассчитано на то, что в конечном итоге они будут превращены в компьютерную программу. В процессе написания программы на основе алгоритма может возникнуть множество подводных камней. Главная опасность заключается в том, что при переводе алгоритма на машинный язык могут быть внесены ошибки, либо окажется, что сама программа написана крайне неэффективно. Поэтому некоторые авторитетные специалисты считают, что до тех пор, пока корректность компьютерной программы не будет доказана с помощью строгих математических выкладок, ее нельзя считать правильной. Они даже разработали специальные методы для выполнения подобных оценок (см. [47]). Однако пока эти методы формальной верификации удается применить только к очень маленьким программам. На практике корректность компьютерных программ все еще проверяется с помощью тестирования. Процесс тестирования является скорее искусством, чем наукой, но это отнюдь не означает, что здесь нечему поучиться.
Тестированию и отладке посвящено довольно много хороших книг, однако их основную мысль можно сформулировать так: в процессе реализации алгоритма программа должна быть тщательно протестирована и отлажена.

Следует также заметить, что в этой книге мы всегда предполагаем, что диапазоны значений входных данных алгоритмов не выходят за заранее оговоренные рамки, поэтому их не нужно проверять. Однако при реализации алгоритмов в виде реально работающих прикладных программ такая проверка просто необходима.

Само собой разумеется, что корректная реализация алгоритма в виде программы является необходимым, но недостаточным условием, поскольку мощь алгоритма можно свести на нет неэффективной реализацией. Современные компиляторы до некоторой степени позволяют застраховаться от этого, особенно при использовании режима оптимизации кода. Тем не менее следует знать о таких стандартных вещах, как вынесение операторов вычисления инвариантного выражения (т.е. такого выражения, которое не изменяется в цикле) за пределы цикла, выделение общих подвыражений, замена медленных операторов их более быстрыми аналогами и т.п. (Хорошее описание методов оптимизации кода программы и других вопросов, связанных с кодированием алгоритмов, можно найти в [15] и [61].) Как правило, применение подобных методов оптимизации может ускорить выполнение программы только на небольшой постоянный множитель, тогда как использование более эффективного алгоритма иногда ускоряет выполнение программы на несколько порядков. Когда алгоритм окончательно выбран, повышение производительности реализующей его программы на 10-50% считается хорошим результатом.

После создания работающей версии программы можно выполнить дополнительный эмпирический анализ лежащего в ее основе алгоритма. Для этого нужно зафиксировать время выполнения программы при разных значениях входных данных, а затем проанализировать полученный результат. Достоинства и недостатки данного метода анализа алгоритмов будут описаны в разделе 2.6.

И в заключение позвольте еще раз подчеркнуть основную идею процесса проектирования и анализа алгоритмов, показанного на рис. 1.2.

<def>Хороший алгоритм получается, как правило, в результате кропотливой циклической работы, связанной с возможными переделками.</def>

Даже если вам крупно повезет и вы придумаете алгоритм, который на первый взгляд кажется идеальным, все равно попытайтесь проанализировать, нельзя ли его еще в чем-то улучшить. Как ни странно, эта мысль не такая уж и плохая, поскольку позволяет получить истинное удовольствие от конечного результата. (Да, да! Кстати я собирался назвать эту книгу как The Joy o f Algorithms.)<n>Это название можно перевести на русский язык как Удовольствие от алгоритмов.</n> С другой стороны, нужно уметь вовремя останавливаться. Что касается реальной жизни, то здесь обычно критерий остановки один — срок сдачи проекта или долготерпение вашего начальника, в зависимости от того, что быстрее закончится. В общем вывод такой: достижение идеала — слишком дорогое удовольствие, которое, к тому же, не всегда нужно. Проектирование алгоритма является достаточно сложной инженерной задачей, связанной с принятием компромиссных решений в условиях ограниченного доступа к ресурсам, одним из которых является время работы проектировщика.

С академической точки зрения затронутый в этом разделе вопрос связан с проведением интересного, но, как правило, очень сложного исследования ***оптимальности*** (optimality) алгоритма. Как ни странно, этот вопрос не относится к эффективности самого алгоритма, а связан со сложностью решаемой с его помощью задачи. То есть необходимо выяснить, какое минимальное количество усилий нужно затратить, чтобы решить стоящую перед вами задачу с помощью произвольного алгоритма? Для некоторых задач ответ на этот вопрос найден. Например, в любом алгоритме сортировки элементов массива методом сравнения необходимо выполнить порядка <tex>n \cdot \log_2 n</tex> операций сравнения, где `n` — размерность массива (см. раздел 10.2). Однако для многих кажущихся простыми задач, типа перемножения матриц, ученым до сих пор так и не удалось найти окончательного ответа.

Еще один важный вопрос, возникающий при решении алгоритмической проблемы, заключается в том, можно ли решить задачу вообще с помощью какого-либо алгоритма? В этой книге мы не будем обсуждать задачи, не имеющие решения, наподобие поиска вещественных корней квадратного уравнения с отрицательным дискриминантом. В подобных случаях алгоритм должен возвращать специальное значение, являющееся признаком того, что задача не имеет решения. Мы не будем также рассматривать неоднозначно определенные задачи. Речь идет о таких задачах, решение которых нельзя найти с помощью любого алгоритма, хотя у них может быть простой ответ — да или нет. Пример такой задачи будет приведен в разделе 10.3. К счастью, подавляющее большинство подобных задач может быть решено с помощью некоторого алгоритма.

И в заключение этого раздела хотелось бы развеять ваши сомнения по поводу того, что проектирование алгоритмов — довольно скучное занятие. Отчасти они могли появиться при взгляде на рис. 1.2, где все четко разложено по полочкам и на первый взгляд нет никакой свободы для творчества. Это абсолютно не соответствует действительности! Изобретение (или поиск?) алгоритмов — творческий и необычайно захватывающий процесс, и я надеюсь, что книга убедит вас в этом.