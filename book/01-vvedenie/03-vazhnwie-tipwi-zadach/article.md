# Важные типы задач

Среди огромного количества задач, встречающихся в вычислительной технике, можно выделить несколько типов, которым ученые всегда уделяли особое внимание. Подобный интерес вызван либо практическим значением задачи, либо какими-то ценными ее свойствами, представляющими особый интерес для исследования. К счастью, в большинстве случаев эти причины взаимосвязаны, что только усиливает интерес ученых.

В этом разделе кратко рассматриваются наиболее важные типы задач:
 
- сортировка;
- поиск;
- обработка строк;
- задачи из теории графов;
- комбинаторные задачи;
- геометрические задачи;
- численные задачи.

Эти задачи будут использоваться в последующих главах книги для иллюстрации различных методов проектирования и анализа алгоритмов.

## Сортировка

***Задача сортировки*** (sorting problem) заключается в упорядочении заданного списка каких-либо элементов в возрастающем порядке<n>Очевидно, что для сортировки в порядке убывания достаточно заменить вид сравнения элементов последовательности на обратный.</n>. Само собой разумеется, что для определенности задачи структура этих элементов списка должна позволять их упорядочить. (В подобных случаях математики говорят, что между элементами должны существовать отношения, допускающие полное упорядочение.) На практике обычно требуется отсортировать по возрастанию список чисел, расположить символы и строки в алфавитном порядке или, что наиболее важно, упорядочить набор записей, содержащих различную информацию, наподобие той, что хранится в папках со сведениями об учащихся школы, в читательских формулярах библиотеки, в отделе кадров о сотрудниках организации. В случае набора записей необходимо выбрать фрагмент записи, содержащий данные, по которым будет осуществляться сортировка. Например, набор записей о студентах можно отсортировать по фамилии, идентификационному номеру или по среднему баллу. Специально отобранный фрагмент данных называется ключом (key). Специалисты по информатике часто говорят о сортировке списка ключей, даже если элементы этого списка являются не записями, а, скажем, целыми числами.

Зачем может понадобиться отсортированный список? Ну, скажем затем, чтобы облегчить поиск ответов на ряд вопросов, связанных со списком. Наибольшую важность при этом имеет быстрота поиска информации. Вот почему словари, телефонные справочники, списки учащихся и т.п. всегда упорядочиваются по алфавиту. В разделе 6.1 будут приведены другие примеры, в которых используется предварительно отсортированный список. Аналогично сортировка используется также как вспомогательный этап в некоторых важных алгоритмах, относящихся к другим предметным областям, например к геометрии.

К настоящему моменту специалистами по вычислительной технике разработаны десятки алгоритмов сортировки. По сути, выдумывание нового алгоритма сортировки можно сравнить с изобретением пресловутого велосипеда. Тем не менее мы с гордостью хотим заявить, что поиск лучших вариантов велосипеда (т.е. алгоритмов сортировки) продолжается. Подобная настойчивость может быть оправданна, если принять во внимание следующие факты. С одной стороны, существует несколько хороших алгоритмов сортировки, в которых для сортировки произвольного массива из `n` элементов используется <tex>n \cdot \log_2 n</tex> операций сравнения. С другой стороны, нет алгоритма, который бы выполнял сортировку методом сравнения всего значения ключа (а не, скажем, небольшой части ключа) за существенно меньшее количество операций, чем было указано выше.

Существует причина, сдерживающая разработку новых алгоритмов сортировки. Несмотря на то что часть алгоритмов оказывается лучше остальных, пока еще не придуман универсальный алгоритм сортировки, который бы наилучшим образом подходил для всех случаев. Одни из существующих алгоритмов являются простыми, но сравнительно медленными, другие работают быстрее, но более сложны. Некоторые из алгоритмов хорошо работают с неупорядоченными данными, тогда как для других нужно, чтобы списки были частично отсортированы. Часть алгоритмов пригодна только для сортировки списков данных, расположенных в оперативной памяти (т.е. в памяти с быстрым доступом), тогда как другие можно применить для сортировки больших массивов данных, расположенных на внешних носителях данных (магнитном диске, ленте и т.д.).

Два свойства алгоритмов сортировки заслуживают особого внимания. Алгоритм сортировки называется устойчивым (stable), если в нем сохраняется относительный порядок любых двух равных элементов, находящихся во входном списке. Другими словами, если во входном списке есть два одинаковых элемента, номера которых равны `i` и `j`, причем ~, то в отсортированном списке, где их номера будут, соответственно, равны `i'` и `j'`, будет выполняться отношение `i' < j'`. Это свойство может пригодиться в случае, если, например, требуется отсортировать упорядоченный в алфавитном порядке список учащихся согласно их успеваемости (среднему баллу). В случае применения устойчивого алгоритма будет получен список, в котором учащиеся с одинаковым средним баллом будут упорядочены по алфавиту. Вообще говоря, алгоритмы сортировки методом обмена значениями ключей, расположенными на значительном расстоянии друг от друга, не являются устойчивыми, однако обычно они работают быстрее. Ниже в этой книге мы покажем, как это общее утверждение применяется к основным алгоритмам сортировки.

Второе важное свойство алгоритмов сортировки связано с количеством дополнительной оперативной памяти, необходимой для работы алгоритма. Алгоритм называют ***обменным*** (in place), если для его работы не требуется дополнительная оперативная память, кроме случаев возможного использования нескольких дополнительных ячеек памяти. Многие важные алгоритмы сортировки относятся к классу обменных, а другие, не менее важные — нет.

## Поиск

Задача ***поиска*** связана с нахождением заданного значения, называемого ключом поиска (search key), среди заданного множества (или мультимножества<n>Мультимножество — это множество, в котором несколько принадлежащих ему элементов могут иметь одинаковые значения.</n>). Существует огромное количество алгоритмов поиска, так что есть из чего выбирать. Их сложность варьируется от самых простых алгоритмов поиска методом последовательного сравнения, до чрезвычайно эффективных, но ограниченных алгоритмов бинарного поиска, а также алгоритмов, основанных на представлении базового множества в иной, более подходящей для выполнения поиска форме. Последние из упомянутых здесь алгоритмов имеют особое практическое значение, поскольку применяются в реально действующих приложениях, выполняющих выборку и хранение массивов информации в огромных базах данных.

Для решения задачи поиска также не существует единого алгоритма, который бы наилучшим образом подходил для всех случаев. Некоторые из алгоритмов выполняются быстрее остальных, но для их работы требуется дополнительная оперативная память. Другие выполняются очень быстро, но их можно применять только для предварительно отсортированных массивов, и т.п. В отличие от алгоритмов сортировки в алгоритмах поиска нет проблемы устойчивости, но при их использовании могут возникать другие сложности. В частности, в тех приложениях, где обрабатываемые данные могут часто изменяться, причем количество изменений сравнимо с количеством операций поиска, поиск следует рассматривать в неразрывной связи с двумя другими операциями — добавления элемента в набор данных и удаления из него. В подобных ситуациях необходимо видоизменить структуры данных и алгоритмы так, чтобы достигалось равновесие между требованиями, выдвигаемыми к каждой операции. Кроме того, организация очень больших наборов данных с целью выполнения в них эффективного поиска (а также добавления и удаления элементов) представляет собой чрезвычайно сложную задачу, решение которой особенно важно с точки зрения практического применения.

## Обработка строк

В связи с быстрым увеличением в последнее время количества приложений, связанных с обработкой нечисловых данных, интерес ученых и специалистов-практиков все больше привлекают алгоритмы обработки строк. ***Строкой*** (string) называется последовательность символов, взятых из заранее определенного алфавита. Практический интерес представляют, например, текстовые строки, состоящие из букв, цифр и специальных символов; битовые строки, состоящие из нулей и единиц; последовательности генов, которые могут быть смоделированы с помощью строк символов, взятых из четырехсимвольного алфавита `{А, C, G, Т}`. Тем не менее стоит отметить, что алгоритмы обработки строк стали важны для вычислительной техники очень давно — с тех пор, как появились первые языки программирования и соответствующие им программы — компиляторы.

Существует одна специфическая задача, которая привлекла особое внимание специалистов по информатике. Речь идет о поиске заданного слова в строке текста. Ее назвали ***поиском подстрок*** (string matching). Для выполнения такого специфического поиска разработано несколько алгоритмов. В главе 3 мы опишем один очень простой алгоритм, а в главе 7 обсудим два алгоритма, созданных на основе замечательной идеи Р. Бойера (R. Boyer) и Дж. Мура (J. Moore).

## Задачи из теории графов

Одной из самых старых и, пожалуй, наиболее интересных областей алгоритмики является обработка графов. Нестрого ***граф*** можно определить как набор точек, называемых вершинами, часть из которых соединена отрезками, называемыми ребрами. (Более строгое определение графа будет дано в следующем разделе.) Графы являются довольно интересным объектом для изучения как с теоретической, так и с практической точек зрения. С помощью графов можно смоделировать довольно большое количество процессов, происходящих в реальной жизни, например функционирование транспортных и коммуникационных сетей, календарное планирование проекта и т.д. Одна из последних интересных задач — оценка “диаметра” Web, заключающаяся в определении максимального количества ссылок, которые нужно пройти от одной Web-страницы до другой по оптимальному маршруту<n>Согласно оценке группы исследователей из университета Нотр-Дама (University of Notre Dame), это количество ссылок составляет всего 19 [6].</n>.

К числу основных алгоритмов теории графов относят следующие:

- алгоритмы обхода графа (этот класс алгоритмов позволяет ответить на такие вопросы, как каким образом можно объехать все узлы железнодорожной сети);
- алгоритмы определения кратчайшего пути (этот класс алгоритмов позволяет ответить на вопросы наподобие следующего: каков кратчайший путь между двумя городами);
- алгоритмы топологической сортировки для ориентированных графов ребрами (этот класс алгоритмов позволяет выяснить, не является ли множество читаемых студентам курсов внутренне противоречивым).

К счастью, все перечисленные алгоритмы можно рассматривать как пример общих методов проектирования. Поэтому вы сможете найти их описание в соответствующих главах книги.

Некоторые из задач теории графов с вычислительной точки зрения очень трудны. Это означает, что только небольшое количество экземпляров подобных задач можно решить за приемлемое время с помощью самого быстродействующего компьютера, который только можно себе представить. К наиболее известным задачам теории графов этого типа вероятнее всего относятся задачи коммивояжера и раскраски графа. Напомним, что задача коммивояжера заключается в нахождении кратчайшего пути между `n` городами, каждый из которых он должен посетить только один раз. Задача ***раскраски графа*** (graph-coloring problem) заключается в том, что нужно с помощью минимального количества красок раскрасить вершины графа так, чтобы не было двух смежных вершин одинакового цвета. Эта задача появляется в процессе решения важных практических задач, таких как, например, календарное планирование. Если представить работы в виде вершин графа и соединить их между собой ребрами тогда и только тогда, когда соответствующие им работы не могут выполняться в одно и то же время, решение задачи раскраски такого графа даст оптимальный график выполнения работ.

## Комбинаторные задачи

С точки зрения обобщения задачи коммивояжера и раскраски графа являются примерами комбинаторных задач. Суть этих задач в конечном итоге сводится к нахождению такого комбинаторного объекта, как перестановка, сочетание или подмножество, который бы удовлетворял определенным ограничениям и обладал заданными свойствами (например, позволял максимизировать прибыль или минимизировать затраты.)

Вообще говоря, комбинаторные задачи относятся к классу самых сложных, как с теоретической, так и с практической точек зрения. Их сложность обусловлена следующим. Во-первых, количество комбинаторных объектов обычно очень быстро растет при увеличении масштаба задачи и достигает невообразимых значений уже при весьма скромных ее масштабах. Во-вторых, пока не существует алгоритмов для поиска точного решения подобных задач за приемлемое время.
Более того, большинство специалистов в области информатики считают, что таких алгоритмов попросту не существует. Это предположение не было ни доказано, ни опровергнуто. Оно до сих пор остается наиболее важным из нерешенных вопросов теоретической информатики. Более подробно этот вопрос мы обсудим в разделе 10.3.

Некоторые комбинаторные задачи можно решить с помощью эффективных алгоритмов, но это скорее счастливое исключение, чем правило.

## Геометрические задачи

***Геометрические алгоритмы*** связаны с такими геометрическими объектами, как точки, линии, многоугольники. Древние греки проявляли большой интерес к разработке процедур (естественно, они их еще не называли алгоритмами) решения различных геометрических задач, среди которых можно назвать построение простых геометрических форм (треугольников, окружностей и т.п.) с помощью неградуированной линейки и циркуля. С тех пор прошло более 2000 лет, и в век компьютеров интерес к геометрическим алгоритмам вспыхнул с новой силой.
Для решения подобных задач линейки и циркули уже не нужны — только биты, байты и накопленный годами человеческий опыт. Естественно, сейчас человечество проявляет совершенно другой интерес к геометрическим алгоритмам. Они нужны для решения современных задач компьютерной графики, робототехники и томографии.

В этой книге мы рассмотрим алгоритмы решения только двух классических задач вычислительной геометрии: поиска пары ближайших точек и определения выпуклой оболочки. Название задачи поиска ***пары ближайших точек*** говорит само за себя: среди `n` точек на плоскости необходимо выбрать пару точек, расположенных наиболее близко друг к другу. При решении задачи построения ***выпуклой оболочки*** необходимо найти наименьший выпуклый многоугольник, который бы охватывал все точки некоторого множества на плоскости. Чтобы больше узнать об этих и других геометрических задачах, обратитесь к специализированным монографиям (например, [90]) или к соответствующим главам учебников, построенных по принципу описания конкретных типов задач (например, [102]).

## Численные задачи

Численные задачи относятся к еще одной довольно обширной области практического использования алгоритмов. Они имеют дело с математическими объектами, которые по своей сути являются непрерывными. Вот примеры типичных численных задач: решение уравнений и систем уравнений, вычисление определенных интегралов и значений функций и т.д. Подавляющее большинство таких задач может быть решено только приблизительно. Еще одна принципиальная трудность заключается в том, что при решении подобных задач обычно нужно выполнять операции с вещественными числами, которые в компьютере могут быть представлены только с определенной погрешностью. Более того, выполнение большого количества арифметических операций над представленными приближенно числами может привести к накоплению ошибок округления, что в свою очередь может кардинально повлиять на точность получаемых результатов.

За прошедшие годы было придумано большое количество довольно сложных алгоритмов решения численных задач, причем они продолжают играть ключевую роль при выполнении научных и инженерных расчетов. Однако в течение последних 25 лет интересы компьютерной индустрии сместились в сторону создания прикладных программ для деловой сферы. Для создания приложений этой категории потребовалось разработать базовые алгоритмы хранения и выборки данных, передачи их по сетям и отображения в удобном для пользователя виде. В результате таких революционных изменений численный анализ утратил былые позиции как в области промышленного, так и научного использования программ. Тем не менее для любого человека, изучающего компьютерную литературу, важно иметь хотя бы элементарные понятия в области численных алгоритмов. Несколько таких классических алгоритмов мы опишем в разделах 6.2, 10.4 и 11.4.

